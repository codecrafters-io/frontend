export default {
  "slug": "redis",
  "name": "Build your own Redis",
  "short_name": "Redis",
  "release_status": "live",
  "description_md": "[Redis](https://redis.io/docs/latest/develop/get-started/data-store/) is an in-memory data structure store often used as a database, cache, message broker and streaming engine. In this challenge\nyou'll build your own Redis server that is capable of serving basic commands, reading RDB files and more.\n\nAlong the way, you'll learn about TCP servers, the Redis Protocol and more.",
  "short_description_md": "Learn about TCP servers, the Redis protocol and more",
  "completion_percentage": 30,
  "concept_slugs": [
    "network-protocols",
    "tcp-overview"
  ],
  "languages": [
    {
      "slug": "c"
    },
    {
      "slug": "clojure"
    },
    {
      "slug": "cpp"
    },
    {
      "slug": "crystal"
    },
    {
      "slug": "csharp"
    },
    {
      "slug": "elixir"
    },
    {
      "slug": "gleam"
    },
    {
      "slug": "go"
    },
    {
      "slug": "haskell"
    },
    {
      "slug": "java"
    },
    {
      "slug": "javascript"
    },
    {
      "slug": "kotlin"
    },
    {
      "slug": "ocaml"
    },
    {
      "slug": "odin"
    },
    {
      "slug": "php"
    },
    {
      "slug": "python"
    },
    {
      "slug": "ruby"
    },
    {
      "slug": "rust"
    },
    {
      "slug": "typescript"
    },
    {
      "slug": "scala"
    },
    {
      "slug": "swift",
      "release_status": "alpha",
      "alpha_tester_usernames": [
        "JWShroyer"
      ]
    },
    {
      "slug": "zig"
    }
  ],
  "marketing": {
    "difficulty": "medium",
    "sample_extension_idea_title": "Persistence",
    "sample_extension_idea_description": "A Redis server that can read and write .rdb files",
    "testimonials": [
      {
        "author_name": "Charles Guo",
        "author_description": "Software Engineer, Stripe",
        "author_avatar": "https://codecrafters.io/images/external/testimonials/charles-guo.png",
        "link": "https://github.com/shaldengeki",
        "text": "The Redis challenge was extremely fun. I ended up having to read the\nRedis Protocol specification doc pretty carefully in its entirety! The result\nfelt like lightly-guided independent study, if that makes sense. (Which, again, was lots of fun)"
      },
      {
        "author_name": "Patrick Burris",
        "author_description": "Senior Software Developer, CenturyLink",
        "author_avatar": "https://codecrafters.io/images/external/testimonials/patrick-burris.jpeg",
        "link": "https://github.com/Jumballaya",
        "text": "I think the instant feedback right there in the git push is really cool.\nDidn't even know that was possible!"
      }
    ]
  },
  "extensions": [
    {
      "slug": "lists",
      "name": "Lists",
      "description_markdown": "In this challenge extension you'll add support for [Lists][redis-lists] to your Redis implementation.\n\nAlong the way, you'll learn commands like [RPUSH][rpush-command], [LRANGE][lrange-command], and more.\n\n[redis-lists]: https://redis.io/docs/latest/develop/data-types/lists/\n[rpush-command]: https://redis.io/docs/latest/commands/rpush/\n[lrange-command]: https://redis.io/docs/latest/commands/lrange/"
    },
    {
      "slug": "streams",
      "name": "Streams",
      "description_markdown": "In this challenge extension you'll add support for the [Stream][redis-streams-data-type] data type to your Redis implementation.\n\nAlong the way you'll learn about commands like [XADD][xadd-command], [XRANGE][xrange-command] and more.\n\n[redis-streams-data-type]: https://redis.io/docs/latest/develop/data-types/streams/\n[xadd-command]: https://redis.io/commands/xadd/\n[xrange-command]: https://redis.io/commands/xrange/"
    },
    {
      "slug": "transactions",
      "name": "Transactions",
      "description_markdown": "In this challenge extension you'll add support for [Transactions][redis-transactions] to your Redis implementation.\n\nAlong the way, you'll learn about the [MULTI][multi-command], [EXEC][exec-command], and [DISCARD][discard-command] commands, as well as how Redis handles transactions atomically.\n\n[redis-transactions]: https://redis.io/docs/latest/develop/interact/transactions/\n[multi-command]: https://redis.io/commands/multi/\n[exec-command]: https://redis.io/commands/exec/\n[discard-command]: https://redis.io/commands/discard/"
    },
    {
      "slug": "replication",
      "name": "Replication",
      "description_markdown": "In this challenge extension you'll add support for [Replication][redis-replication] to your Redis implementation.\n\nAlong the way you'll learn about how Redis's leader-follower replication works, the [PSYNC][redis-psync-command] command and more.\n\n[redis-replication]: https://redis.io/docs/latest/operate/oss_and_stack/management/replication/\n[redis-psync-command]: https://redis.io/commands/psync/\n"
    },
    {
      "slug": "persistence-rdb",
      "name": "RDB Persistence",
      "description_markdown": "In this challenge extension you'll add [persistence][redis-persistence] support to your Redis implementation.\n\nAlong the way you'll learn about Redis's [RDB file format][rdb-file-format] and more.\n\n[redis-persistence]: https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/\n[rdb-file-format]: https://github.com/sripathikrishnan/redis-rdb-tools/blob/548b11ec3c81a603f5b321228d07a61a0b940159/docs/RDB_File_Format.textile\n"
    },
    {
      "slug": "pub-sub",
      "name": "Pub/Sub",
      "description_markdown": "In this challenge extension you'll add support for [Publish/Subscribe (Pub/Sub)][redis-pub-sub] to your Redis implementation.\n\nAlong the way, you'll learn commands like [SUBSCRIBE][subscribe-command], [PUBLISH][publish-command], and more.\n\n[redis-pub-sub]: https://redis.io/docs/latest/develop/pubsub/\n[subscribe-command]: https://redis.io/docs/latest/commands/subscribe/\n[publish-command]: https://redis.io/docs/latest/commands/publish/"
    },
    {
      "slug": "sorted-sets",
      "name": "Sorted Sets",
      "description_markdown": "In this challenge extension you'll add support for [Sorted Sets (zsets)][redis-zset] to your Redis implementation.\n\nAlong the way, you'll learn commands like [ZADD][zadd-command], [ZRANGE][zrange-command], and more.\n\n[redis-zset]: https://redis.io/docs/latest/develop/data-types/sorted-sets/\n[zadd-command]: https://redis.io/docs/latest/commands/zadd/\n[zrange-command]: https://redis.io/docs/latest/commands/zrange/"
    },
    {
      "slug": "geospatial",
      "name": "Geospatial Commands",
      "description_markdown": "In this challenge extension you'll add support for [Geospatial Commands][geospatial-commands] to your Redis implementation.\n\nAlong the way, you'll learn commands like [GEOADD][geoadd-command], [GEOSEARCH][geosearch-command], and more.\n\n[geospatial-commands]: https://redis.io/docs/latest/develop/data-types/geospatial/\n[geoadd-command]: https://redis.io/docs/latest/commands/geoadd/\n[geosearch-command]: https://redis.io/docs/latest/commands/geosearch/\n"
    }
  ],
  "stages": [
    {
      "slug": "jm1",
      "concept_slugs": [
        "network-protocols",
        "tcp-overview",
        "go-tcp-server",
        "rust-tcp-server",
        "python-tcp-server"
      ],
      "name": "Bind to a port",
      "difficulty": "very_easy",
      "marketing_md": "In this stage, you'll start a TCP server on port 6379, which is the\ndefault port that Redis uses.",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_bind.go#L11",
      "description_md": "In this stage, you'll implement a TCP server that listens on port 6379.\n\n### TCP (Transmission Control Protocol)\n\n[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) is the underlying protocol used by protocols like HTTP, SSH, and others you're probably familiar with. Redis also uses TCP for communication between its clients and servers.\n\nDon't worry if you're unfamiliar with the TCP protocol, or what Redis clients & servers are. You'll learn more about this in the next stages.\n\nFor this stage, your program should act as a basic TCP server that listens for incoming connections on port 6379.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then attempt to connect to your TCP server on port 6379. If the connection succeeds, you’ll pass this stage.\n\n### Notes\n\n- Port 6379 is the default port used by Redis.\n- If you already have a Redis server running on your machine, you’ll see a “port already in use” error. To fix this, stop the existing Redis server before running your code.\n\n{{#reader_is_bot}}\n- In this stage, you can assume that you only need to handle a single client. We'll get to handling multiple clients & multiple requests per client in later stages.\n{{/reader_is_bot}}\n"
    },
    {
      "slug": "rg2",
      "concept_slugs": [
        "network-protocols",
        "tcp-overview",
        "go-tcp-server",
        "rust-tcp-server",
        "python-tcp-server"
      ],
      "name": "Respond to PING",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll respond to the\n[PING](https://redis.io/commands/ping) command. You'll use [the Redis\nprotocol](https://redis.io/topics/protocol) to encode the reply.\n",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_ping_pong.go#L9",
      "description_md": "In this stage, you'll implement support for the [PING](https://redis.io/commands/ping) command.\n\n### Redis Commands\n\nRedis clients communicate with Redis servers by sending [commands](https://redis.io/commands/). For each command, a Redis server sends a response back to the client.\n\nFor example:\n```bash\n$ redis-cli SET name Alice\nOK\n```\nHere, the client sends a [`SET`](https://redis.io/docs/latest/commands/set/) command to store the key `name` with the value `Alice`. The server responds with `OK`, confirming that the action was successful.\n\n\nBoth commands and responses are encoded using the [Redis serialization protocol (RESP)](https://redis.io/docs/latest/develop/reference/protocol-spec/). We'll learn more about this in later stages.\n\n### The `PING` Command\n\n[PING](https://redis.io/commands/ping/) is one of the simplest Redis commands. It's used to check whether a Redis server is healthy.\n\n```bash\n$ redis-cli PING\nPONG\n```\n\nThe response for the `PING` command is `+PONG\\r\\n`. This is the string \"PONG\" encoded as a [RESP simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\nIn this stage, you can ignore the client input and simply hardcode `+PONG\\r\\n` as a response. We'll get to parsing the client's input in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt'll then send a `PING` command to your server.\n\n```bash\n$ redis-cli PING\n```\n\nYour server should respond with `+PONG\\r\\n`, which is `PONG` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\n### Notes\n\n- You can ignore the data that the tester sends you for this stage. We'll get to parsing\nclient input in later stages. For now, you can just hardcode `+PONG\\r\\n` as the response.\n- You can also ignore handling multiple clients and handling multiple PING commands in this stage—we'll get to that in later stages.\n- The exact bytes your program will receive won't just be `PING`. Instead, you'll receive something like this: `*1\\r\\n$4\\r\\nPING\\r\\n`,\nwhich is the Redis protocol encoding of the `PING` command. We'll learn more about this in later stages.\n"
    },
    {
      "slug": "wy1",
      "concept_slugs": [
        "network-protocols",
        "tcp-overview",
        "go-tcp-server",
        "rust-tcp-server",
        "python-tcp-server"
      ],
      "name": "Respond to multiple PINGs",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll respond to multiple\n[PING](https://redis.io/commands/ping) commands sent by the same client.",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_ping_pong.go#L35",
      "description_md": "In this stage, you'll respond to multiple [PING](https://redis.io/commands/ping) commands sent by the same connection.\n\n### Handling Multiple Commands\n\nA Redis server starts to listen for the next command as soon as it's done responding to the previous one. This allows\nRedis clients to send multiple commands using the same connection.\n\nFor this stage, your server should run a loop that continuously reads commands and sends responses back through the same connection. Since we're only dealing with the `PING` command for now, your program can run a loop that reads input and responds with `+PONG\\r\\n`.\n\n{{#lang_is_javascript}}\nIn most languages, you'd need to write specific code to run this loop on your server. In JavaScript, however, if you're listening to the [`data`](https://nodejs.org/api/net.html#net_event_data) event, this should be automatically handled for you. **It is very likely that the code you used in the previous stage will pass this stage without any changes!**\n{{/lang_is_javascript}}\n\n{{#lang_is_typescript}}\nIn most languages, you'd need to write specific code to run this loop on your server. In JavaScript, however, if you're listening to the [`data`](https://nodejs.org/api/net.html#net_event_data) event, this should be automatically handled for you. **It is very likely that the code you used in the previous stage will pass this stage without any changes!**\n{{/lang_is_typescript}}\n\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send multiple `PING` commands using the same connection. For example, it might send:\n\n```bash\n$ echo -e \"PING\\nPING\" | redis-cli\n```\n\nThe tester will expect to receive a `+PONG\\r\\n` response for each command sent.\n\n### Notes\n\n- The exact bytes your program will receive won't be just `PING`. You'll receive something like this: `*1\\r\\n$4\\r\\nPING\\r\\n`, which is the Redis protocol encoding of the `PING` command.\n- Just like the previous stage, you can hardcode `+PONG\\r\\n` as the response for this stage. We'll get to parsing client input in later stages.\n- The tester will send the `PING` commands using the same connection. We'll get to handling multiple connections in later stages.\n"
    },
    {
      "slug": "zu2",
      "concept_slugs": [
        "network-protocols",
        "tcp-overview",
        "go-tcp-server",
        "rust-tcp-server",
        "python-tcp-server"
      ],
      "name": "Handle concurrent clients",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for multiple concurrent clients to your\nRedis server. To achieve this you'll use an [Event\nLoop](https://en.wikipedia.org/wiki/Event_loop),\nlike the official Redis implementation does.",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_ping_pong.go#L56",
      "description_md": "In this stage, you'll add support for multiple concurrent clients.\n\n### Handling Multiple Clients\n\nIn addition to handling multiple commands from the same client, Redis servers can also handle multiple clients at once.\n\n{{#lang_is_javascript}}\nIn most languages, you'd need to either use threads or implement an\n[Event Loop](https://en.wikipedia.org/wiki/Event_loop) to do this. In JavaScript, however, since [the concurrency\nmodel itself is based on an event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), most\nstandard library functions are designed to support this kind of concurrent behaviour out of the box. **It is very\nlikely that the code you had for the previous stage will pass this stage without any changes!**\n{{/lang_is_javascript}}\n\n{{#lang_is_typescript}}\nIn most languages, you'd need to either use threads or implement an [Event Loop](https://en.wikipedia.org/wiki/Event_loop) to do this. In JavaScript, however, since [the concurrency\nmodel itself is based on an event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), most standard library functions are designed to support this kind of concurrent behaviour out of the box. **It is very likely that the code you had for the previous stage will pass this stage without any changes!**\n{{/lang_is_typescript}}\n\n{{^lang_is_javascript}}\n  {{^lang_is_typescript}}\nTo implement this, you'll need to either use threads or, if you're feeling adventurous, implement an [Event Loop](https://en.wikipedia.org/wiki/Event_loop) (like the official Redis implementation does).\n  {{/lang_is_typescript}}\n{{/lang_is_javascript}}\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt'll then send two `PING` commands concurrently using two different connections:\n\n```bash\n# These two will be sent concurrently so that we can test your server's ability to handle concurrent clients.\n$ redis-cli PING\n$ redis-cli PING\n```\nThe tester will expect to receive two separate `+PONG\\r\\n` responses.\n\n### Notes\n\n- Since the tester client _only_ sends the `PING` command at the moment, it's okay to\n  ignore what the client sends and hardcode a response. We'll get to parsing\n  client input in later stages.\n"
    },
    {
      "slug": "qq0",
      "name": "Implement the ECHO command",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll respond to the\n[ECHO](https://redis.io/commands/echo) command. You'll parse user input\naccording to the [the Redis protocol\nspecification](https://redis.io/topics/protocol).",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_echo.go#L11",
      "description_md": "In this stage, you'll add support for the [ECHO](https://redis.io/commands/echo) command.\n\n### The `ECHO` Command\n\nThe `ECHO` command is used for testing and debugging, similar to `PING`. \n\n```bash\n$ redis-cli PING # The command you implemented in the previous stages\nPONG\n$ redis-cli ECHO hey # The command you'll implement in this stage\nhey\n```\n\nIt accepts a single argument and sends it back as a [RESP bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\nTo pass this stage, your program will need to:\n- Parse the client's input to extract the argument from the `ECHO` command\n- Then encode that argument as a bulk string for the response\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt'll then send an `ECHO` command with an argument to your server:\n\n```bash\n$ redis-cli ECHO hey\n```\n\nThe exact bytes you'll receive will be a [RESP Array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays) that looks something like `*2\\r\\n$4\\r\\nECHO\\r\\n$3\\r\\nhey\\r\\n`. This is the RESP encoding of `[\"ECHO\", \"hey\"]`.\n\nThe tester will expect to receive `$3\\r\\nhey\\r\\n` as a response. That's the string `hey` encoded as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\n### Notes\n\n- We highly recommend you implement a proper RESP parser at this stage. It'll come in handy in later stages.\n- Redis command names are case-insensitive, so `ECHO`, `echo`, and `EcHo` are all valid commands.\n- The tester will send a random string as an argument to the `ECHO` command, so you won't be able to hardcode the response to pass this stage.\n"
    },
    {
      "slug": "la7",
      "name": "Implement the SET & GET commands",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll need to implement the\n[SET](https://redis.io/commands/set) &\n[GET](https://redis.io/commands/get) commands.",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_get_set.go#L11",
      "description_md": "In this stage, you'll add support for the [SET](https://redis.io/commands/set) &\n[GET](https://redis.io/commands/get) commands.\n\n### The `SET` Command\n\nThe `SET` command is used to set a key to a value. For example, a client can set a key `foo` to a value `bar` like this:\n```bash\n$ redis-cli SET foo bar\nOK\n```\nThe server then responds with `OK` (as a [RESP simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings)) to confirm that the action was successful.\n\nThe `SET` command supports a number of extra options like `EX` (expiry time in seconds), `PX` (expiry time in milliseconds), and more. We\nwon't cover these extra options in this stage. We'll get to them in later stages.\n\n### The `GET` Command\n\nThe `GET` command is used to retrieve the value of a key. For example, to retrieve the value for the key `foo`:\n```bash\n$ redis-cli GET foo\nbar\n```\nThe server responds with the value `bar` encoded as a [RESP bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings). If the key doesn't exist, the server responds with a special [null bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-bulk-strings) (`$-1\\r\\n`).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n./your_program.sh\n```\n\nIt'll then send a `SET` command to your server:\n\n```bash\n$ redis-cli SET foo bar\n```\n\nThe tester will expect to receive `+OK\\r\\n` as a response. That's the string `OK` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\nThis command will be followed by a `GET` command:\n\n```bash\n$ redis-cli GET foo\n```\n\nThe tester will expect to receive `$3\\r\\nbar\\r\\n` as a response. That's the string `bar` encoded as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\n### Notes\n\n- If you implemented a proper RESP parser in the previous stage, you should be able to reuse it in this stage.\n- Just like the previous stage, the values used for keys and values will be random, so you won't be able to hardcode the response to pass this stage.\n- If a key doesn't exist, the `GET` command should return a [null bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-bulk-strings) (`$-1\\r\\n`). We won't explicitly test this in this stage, but you'll need it for the next stage.\n"
    },
    {
      "slug": "yz1",
      "name": "Expiry",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for setting a key with an expiry. The\nexpiry is provided using the \"PX\" argument to the\n[SET](https://redis.io/commands/set) command.",
      "tester_source_code_url": "https://github.com/codecrafters-io/redis-tester/blob/master/internal/test_expiry.go",
      "description_md": "In this stage, you'll add support for setting a key with an expiry.\n\n### `SET` Command Options\n\nThe `SET` command can accept [optional arguments](https://redis.io/docs/latest/commands/set/#options) to modify its behaviour.\n\nFor example, here are a few options you can use with `SET`:\n\n```bash\n# Set a key with a 10-second expiry\n$ redis-cli SET mykey value EX 10\nOK\n\n# Set a key with a 1000-millisecond expiry\n$ redis-cli SET mykey value PX 1000\nOK\n```\n\n### The `PX` Option\n\nThe `PX` option is used to set a key's expiry time in milliseconds. After the key expires, it's no longer accessible.\n\nFor example, a client can set a key with an expiry like this:\n```bash\n$ redis-cli SET foo bar PX 100\nOK\n```\nThis command sets the key `foo` to the value `bar` with an expiry of 100 milliseconds.\n\nAfter the key expires, a `GET` command for that key should return a [null bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-bulk-strings) (`$-1\\r\\n`).\n\n```bash\n$ redis-cli GET foo\n(nil)\n```\n\n{{#lang_is_haskell}}\nThe [time](https://hackage.haskell.org/package/time) package is available\nto use as a dependency.\n{{/lang_is_haskell}}\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nNext, it will send a `SET` command to your server to set a key with an expiry:\n\n```bash\n$ redis-cli SET foo bar PX 100\n```\n\nImmediately after that, it will send a `GET` command to retrieve the value of the key:\n\n```bash\n$ redis-cli GET foo\n```\n\nThe tester will expect to receive `$3\\r\\nbar\\r\\n` as a response. That's the string `bar` encoded as a bulk string.\n\nAfter waiting for the key to expire, it will send another `GET` command:\n\n```bash\n$ sleep 0.2 && redis-cli GET foo\n```\n\nThe tester will expect the response to be a null bulk string (`$-1\\r\\n`).\n\n### Notes\n\n- Just like command names, command arguments are also case-insensitive. So `PX`, `px`, and `pX` are all valid.\n- The keys, values, and expiry times used in the tests will be random, so you won't be able to hardcode a response to pass this stage.\n"
    },
    {
      "slug": "zg5",
      "primary_extension_slug": "persistence-rdb",
      "name": "RDB file config",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for reading the config values related to where RDB files are stored. You'll implement the `CONFIG GET` command.\n",
      "description_md": "Welcome to the RDB Persistence Extension! In this extension, you'll add support for reading [RDB files](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/) (Redis Database files).\n\nIn this stage, you'll add support for two configuration parameters related to RDB persistence, as well as the [CONFIG GET](https://redis.io/docs/latest/commands/config-get/) command.\n\n### RDB files\n\nAn RDB file is a point-in-time snapshot of a Redis dataset. When RDB persistence is enabled, the Redis server syncs its in-memory state with an RDB file, by doing the following:\n\n1. On startup, the Redis server loads the data from the RDB file.\n2. While running, the Redis server periodically takes new snapshots of the dataset, in order to update the RDB file.\n\n### `dir` and `dbfilename`\n\nThe configuration parameters `dir` and `dbfilename` specify where an RDB file is stored:\n- `dir` - the path to the directory where the RDB file is stored (example: `/tmp/redis-data`)\n- `dbfilename` - the name of the RDB file (example: `rdbfile`)\n\n### The `CONFIG GET` command\n\nThe [`CONFIG GET`](https://redis.io/docs/latest/commands/config-get/) command returns the values of configuration parameters.\n\nIt takes in one or more configuration parameters and returns a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays) of key-value pairs:\n\n```bash\n$ redis-cli CONFIG GET dir\n1) \"dir\"\n2) \"/tmp/redis-data\"\n```\n\nAlthough `CONFIG GET` can fetch multiple parameters at a time, the tester will only send `CONFIG GET` commands with one parameter at a time.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n./your_program.sh --dir /tmp/redis-files --dbfilename dump.rdb\n```\n\nIt'll then send the following commands:\n\n```bash\n$ redis-cli CONFIG GET dir\n$ redis-cli CONFIG GET dbfilename\n```\n\nYour server must respond to each `CONFIG GET` command with a RESP array containing two elements:\n\n1. The parameter **name**, encoded as a [RESP Bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings)\n2. The parameter **value**, encoded as a RESP Bulk string\n\nFor example, if the value of `dir` is `/tmp/redis-files`, then the expected response to `CONFIG GET dir` is:\n\n```bash\n*2\\r\\n$3\\r\\ndir\\r\\n$16\\r\\n/tmp/redis-files\\r\\n\n```\n\n### Notes\n\n- You don't need to read the RDB file in this stage, you only need to store `dir` and `dbfilename`. Reading from the file will be covered in later stages.\n- If your repository was created before 5th Oct 2023, it's possible that your `./your_program.sh` script is not passing arguments to your program. To fix this, you'll need to edit `./your_program.sh`. Check the [update CLI args PR](https://github.com/codecrafters-io/build-your-own-redis/pull/89/files) for details on how to do this.\n"
    },
    {
      "slug": "jz6",
      "primary_extension_slug": "persistence-rdb",
      "name": "Read a key",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for reading a key from an RDB file that contains a single key-value pair. You'll do this by implementing the `KEYS *` command.\n",
      "description_md": "In this stage, you'll add support for reading a single key from an RDB file.\n\n### RDB file format\n\n<details>\n  <summary>Click to expand/collapse</summary>\n#### RDB file format overview\n\nHere are the different sections of the RDB file, in order:\n\n1.  Header section\n2.  Metadata section\n3.  Database section\n4.  End of file section\n\nRDB files use special encodings to store different types of data. The ones relevant to this stage are \"size encoding\" and \"string encoding.\" These are explained near the end of this page.\n\nThe following breakdown of the RDB file format is based on [Redis RDB File Format](https://rdb.fnordig.de/file_format.html) by Jan-Erik Rediger. We’ve only included the parts that are relevant to this stage.\n\n#### Header section\n\nRDB files begin with a header section, which looks something like this:\n```\n52 45 44 49 53 30 30 31 31  // Magic string + version number (ASCII): \"REDIS0011\".\n```\n\nThe header contains the magic string `REDIS`, followed by a four-character RDB version number. In this challenge, the test RDB files all use version 11. So, the header is always `REDIS0011`.\n\n#### Metadata section\n\nNext is the metadata section. It contains zero or more \"metadata subsections,\" which each specify a single metadata attribute. Here's an example of a metadata subsection that specifies `redis-ver`:\n```\nFA                             // Indicates the start of a metadata subsection.\n09 72 65 64 69 73 2D 76 65 72  // The name of the metadata attribute (string encoded): \"redis-ver\".\n06 36 2E 30 2E 31 36           // The value of the metadata attribute (string encoded): \"6.0.16\".\n```\n\nThe metadata name and value are always string encoded.\n\n#### Database section\n\nNext is the database section. It contains zero or more \"database subsections,\" which each describe a single database. Here's an example of a database subsection:\n```\nFE                       // Indicates the start of a database subsection.\n00                       /* The index of the database (size encoded).\n                            Here, the index is 0. */\n\nFB                       // Indicates that hash table size information follows.\n03                       /* The size of the hash table that stores the keys and values (size encoded).\n                            Here, the total key-value hash table size is 3. */\n02                       /* The size of the hash table that stores the expires of the keys (size encoded).\n                            Here, the number of keys with an expiry is 2. */\n```\n\n```\n00                       /* The 1-byte flag that specifies the value’s type and encoding.\n                            Here, the flag is 0, which means \"string.\" */\n06 66 6F 6F 62 61 72     // The name of the key (string encoded). Here, it's \"foobar\".\n06 62 61 7A 71 75 78     // The value (string encoded). Here, it's \"bazqux\".\n```\n\n```\nFC                       /* Indicates that this key (\"foo\") has an expire,\n                            and that the expire timestamp is expressed in milliseconds. */\n15 72 E7 07 8F 01 00 00  /* The expire timestamp, expressed in Unix time,\n                            stored as an 8-byte unsigned long, in little-endian (read right-to-left).\n                            Here, the expire timestamp is 1713824559637. */\n00                       // Value type is string.\n03 66 6F 6F              // Key name is \"foo\".\n03 62 61 72              // Value is \"bar\".\n```\n\n```\nFD                       /* Indicates that this key (\"baz\") has an expire,\n                            and that the expire timestamp is expressed in seconds. */\n52 ED 2A 66              /* The expire timestamp, expressed in Unix time,\n                            stored as an 4-byte unsigned integer, in little-endian (read right-to-left).\n                            Here, the expire timestamp is 1714089298. */\n00                       // Value type is string.\n03 62 61 7A              // Key name is \"baz\".\n03 71 75 78              // Value is \"qux\".\n```\n\nHere's a more formal description of how each key-value pair is stored:\n\n1. Optional expire information (one of the following):\n    * Timestamp in seconds:\n          1.  `FD`\n          2.  Expire timestamp in seconds (4-byte unsigned integer)\n    * Timestamp in milliseconds:\n          1.  `FC`\n          2.  Expire timestamp in milliseconds (8-byte unsigned long)\n2. Value type (1-byte flag)\n3. Key (string encoded)\n4. Value (encoding depends on value type)\n\n#### End of file section\n\nThis section marks the end of the file. It looks something like this:\n```\nFF                       /* Indicates that the file is ending,\n                            and that the checksum follows. */\n89 3b b7 4e f8 0f 77 19  // An 8-byte CRC64 checksum of the entire file.\n```\n\n#### Length encoding\n\nLength-encoded values specify the length or size of something. Here are some examples:\n- The database indexes and hash table sizes are length encoded.\n- String encoding begins with a length-encoded value that specifies the number of characters in the string.\n- List encoding begins with a length-encoded value that specifies the number of elements in the list.\n\nThe first (most significant) two bits of a length-encoded value indicate how the value should be parsed. Here's a guide (bits are shown in both hexadecimal and binary):\n```\n/* If the first two bits are 0b00:\n   The length is the remaining 6 bits of the byte.\n   In this example, the length is 10: */\n0A\n00001010\n\n/* If the first two bits are 0b01:\n   The length is the next 14 bits\n   (remaining 6 bits in the first byte, combined with the next byte),\n   in big-endian (read left-to-right).\n   In this example, the length is 700: */\n42 BC\n01000010 10111100\n\n/* If the first two bits are 0b10:\n   Ignore the remaining 6 bits of the first byte.\n   The length is the next 4 bytes, in big-endian (read left-to-right).\n   In this example, the length is 17000: */\n80 00 00 42 68\n10000000 00000000 00000000 01000010 01101000\n\n/* If the first two bits are 0b11:\n   The remaining 6 bits specify a type of string encoding.\n   See string encoding section. */\n```\n\n#### String encoding\n\nA string-encoded value consists of two parts:\n1.  The size of the string (size encoded).\n2.  The string.\n\nHere's an example:\n```\n/* The 0x0D size specifies that the string is 13 characters long.\n   The remaining characters spell out \"Hello, World!\". */\n0D 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21\n```\n\nFor sizes that begin with `0b11`, the remaining 6 bits indicate a type of string format:\n```\n/* The 0xC0 size indicates the string is an 8-bit integer.\n   In this example, the string is \"123\". */\nC0 7B\n\n/* The 0xC1 size indicates the string is a 16-bit integer.\n   The remaining bytes are in little-endian (read right-to-left).\n   In this example, the string is \"12345\". */\nC1 39 30\n\n/* The 0xC2 size indicates the string is a 32-bit integer.\n   The remaining bytes are in little-endian (read right-to-left),\n   In this example, the string is \"1234567\". */\nC2 87 D6 12 00\n\n/* The 0xC3 size indicates that the string is compressed with the LZF algorithm.\n   You will not encounter LZF-compressed strings in this challenge. */\nC3 ...\n```\n</details>\n\n\n### The `KEYS` command\n<details>\n  <summary>Click to expand/collapse</summary>\n\nThe [`KEYS command`](https://redis.io/docs/latest/commands/keys/) returns all the keys that match a given pattern, as a RESP array:\n```\n$ redis-cli SET foo bar\nOK\n$ redis-cli SET baz qux\nOK\n$ redis-cli KEYS \"f*\"\n1) \"foo\"\n```\n\nWhen the pattern is `*`, the command returns all the keys in the database:\n```\n$ redis-cli KEYS \"*\"\n1) \"baz\"\n2) \"foo\"\n```\n\nIn this stage, you must add support for the `KEYS` command. However, you only need to support the `*` pattern.\n</details>\n\n### Tests\n\nThe tester will create an RDB file with a single key and execute your program like this:\n```\n$ ./your_program.sh --dir <dir> --dbfilename <filename>\n```\n\nIt'll then send a `KEYS \"*\"` command to your server.\n```\n$ redis-cli KEYS \"*\"\n```\n\nYour server must respond with a RESP array that contains the key from the RDB file:\n```\n*1\\r\\n$3\\r\\nfoo\\r\\n\n```\n\n### Notes\n\n- The RDB file provided by `--dir` and `--dbfilename` might not exist. If the file doesn't exist, your program must treat the database as empty.\n- RDB files use both little-endian and big-endian to store numbers. See the [MDN article on endianness](https://developer.mozilla.org/en-US/docs/Glossary/Endianness) to learn more.\n- To generate an RDB file, use the [`SAVE` command](https://redis.io/docs/latest/commands/save/).\n"
    },
    {
      "slug": "gc6",
      "primary_extension_slug": "persistence-rdb",
      "name": "Read a string value",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for reading the value of a key from an RDB file that contains a single key-value pair.\n",
      "description_md": "In this stage, you'll add support for reading the value corresponding to a key from an RDB file.\n\nJust like with the previous stage, we'll stick to supporting RDB files that contain a single key for now.\n\nThe tester will create an RDB file with a single key and execute your program like this:\n\n```\n./your_program.sh --dir <dir> --dbfilename <filename>\n```\n\nIt'll then send a `GET <key>` command to your server.\n\n```bash\n$ redis-cli GET \"foo\"\n```\n\nThe response to `GET <key>` should be a RESP bulk string with the value of the key.\n\nFor example, let's say the RDB file contains a key called `foo` with the value `bar`. The expected response will be `$3\\r\\nbar\\r\\n`.\n\nStrings can be encoded in three different ways in the RDB file format:\n\n- Length-prefixed strings\n- Integers as strings\n- Compressed strings\n\nIn this stage, you only need to support length-prefixed strings. We won't cover the other two types in this challenge.\n\nWe recommend using [this blog post](https://rdb.fnordig.de/file_format.html) as a reference when working on this stage.\n"
    },
    {
      "slug": "jw4",
      "primary_extension_slug": "persistence-rdb",
      "name": "Read multiple keys",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for reading multiple keys from an RDB file. You'll do this by extending the `KEYS *` command to support multiple keys.\n",
      "description_md": "In this stage, you'll add support for reading multiple keys from an RDB file.\n\nThe tester will create an RDB file with multiple keys and execute your program like this:\n\n```bash\n$ ./your_program.sh --dir <dir> --dbfilename <filename>\n```\n\nIt'll then send a `KEYS *` command to your server.\n\n```bash\n$ redis-cli KEYS \"*\"\n```\n\nThe response to `KEYS *` should be a RESP array with the keys as elements.\n\nFor example, let's say the RDB file contains two keys: `foo` and `bar`. The expected response will be:\n\n```\n*2\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n\n```\n\n- `*2\\r\\n` indicates that the array has two elements\n- `$3\\r\\nfoo\\r\\n` indicates that the first element is a bulk string with the value `foo`\n- `$3\\r\\nbar\\r\\n` indicates that the second element is a bulk string with the value `bar`\n"
    },
    {
      "slug": "dq3",
      "primary_extension_slug": "persistence-rdb",
      "name": "Read multiple string values",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for reading multiple string values from an RDB file.\n",
      "description_md": "In this stage, you'll add support for reading multiple string values from an RDB file.\n\nThe tester will create an RDB file with multiple keys and execute your program like this:\n\n```bash\n$ ./your_program.sh --dir <dir> --dbfilename <filename>\n```\n\nIt'll then send multiple `GET <key>` commands to your server.\n\n```bash\n$ redis-cli GET \"foo\"\n$ redis-cli GET \"bar\"\n```\n\nThe response to each `GET <key>` command should be a RESP bulk string with the value corresponding to the key.\n"
    },
    {
      "slug": "sm4",
      "primary_extension_slug": "persistence-rdb",
      "name": "Read value with expiry",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for reading values that have an expiry set.\n",
      "description_md": "In this stage, you'll add support for reading values that have an expiry set.\n\nThe tester will create an RDB file with multiple keys. Some of these keys will have an expiry set, and some won't. The expiry timestamps\nwill also be random, some will be in the past and some will be in the future.\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh --dir <dir> --dbfilename <filename>\n```\n\nIt'll then send multiple `GET <key>` commands to your server.\n\n```bash\n$ redis-cli GET \"foo\"\n$ redis-cli GET \"bar\"\n```\n\nWhen a key has expired, the expected response is `$-1\\r\\n` (a \"null bulk string\").\n\nWhen a key hasn't expired, the expected response is a RESP bulk string with the value corresponding to the key.\n"
    },
    {
      "slug": "bw1",
      "primary_extension_slug": "replication",
      "name": "Configure listening port",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for parsing the `--port` flag and starting Redis on a custom port.\n",
      "description_md": "In this stage, you'll add support for starting the Redis server on a custom port.\n\n### Leader-Follower Replication\n\nThe [leader-follower replication](https://redis.io/docs/latest/operate/oss_and_stack/management/replication/) is a pattern where one server (the \"master\") handles all write operations, and one or more servers (the \"replicas\") maintain copies of the master's data. When the master changes data, it automatically copies those changes to the replicas. This system provides data redundancy and improves read performance.\n\n### Custom Port Support\n\nSince replication requires running multiple Redis servers simultaneously, each instance needs its own port. This means a Redis server must be able to start on a port other than the default `6379`.\n\nThe `--port` flag passes the port number to the Redis server:\n\n```bash\n./your_program.sh --port <port_number>\n```\n\nThe server then parses this argument and starts a TCP server on the specified port.\n\nIf you don’t provide a `--port` flag, the Redis server defaults to port `6379`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port 6380\n```\n\nIt'll then try to connect to your TCP server on the specified port number. If the connection succeeds, you'll pass this stage.\n\n### Notes\n\n- The tester will pass a random port number to your program, so you can't hardcode the port number from the example above.\n- If your repository was created before 5th Oct 2023, it's possible that your `./your_program.sh` script\nmight not be passing arguments on to your program. You'll need to edit `./your_program.sh` to fix this, check\n[this PR](https://github.com/codecrafters-io/build-your-own-redis/pull/89/files) for details.\n"
    },
    {
      "slug": "ye5",
      "primary_extension_slug": "replication",
      "name": "The INFO command",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for the INFO command on the master.\n",
      "description_md": "In this stage, you'll add support for responding to the [INFO](https://redis.io/commands/info/) command as a master server.\n\n### The `INFO` Command\n\nThe `INFO` command returns information and statistics about a running Redis server. For example, a client can get information about a server like this:\n\n```bash\n$ redis-cli INFO\n# Server\nredis_version:7.2.4\n...\n# Clients\nconnected_clients:1\n...\n# Memory\nused_memory:859944\n...\n# Replication\nrole:master\n...\n```\n\nThe server then responds with a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings), where each line is a key-value pair separated by a colon (`:`). The string can also contain section header lines (starting with `#`) and blank lines.\n\nThe `INFO` command also accepts an optional parameter to specify which section of information to display, such as `server`, `memory`, or `replication`. For this stage, we'll only focus on the `replication` section.\n\n### The `replication` Section\n\nWhen you run the `INFO` command with the `replication` argument, the server returns only the details concerning its replication setup:\n\n```\n$ redis-cli INFO replication\n# Replication\nrole:master\nconnected_slaves:0\nmaster_replid:8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:\n```\n\nHere are what some of the important fields mean:\n\n- `role`: The role of the server (either `master` or `slave`).\n- `connected_slaves`: The number of connected replica servers.\n- `master_replid`: The replication ID of the master.\n- `master_repl_offset`: The replication offset of the master.\n\nIn this stage, you'll only need to support the `role` key. We'll add support for other keys in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT>\n```\n\nIt will then send the `INFO` command with `replication` as an argument.\n\n```bash\n$ redis-cli -p <PORT> info replication\n```\n\nYour server should respond with a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings) where each line\nis a key value pair separated by a colon (`:`). The tester will only look for the `role` key and assert that the value is `master`.\n\n### Notes\n\n- In the response for the `INFO` command, you only need to support the `role` key for this stage. We'll add support for the other keys in later stages.\n- The `# Replication` heading in the response is optional, and you can ignore it.\n- The response to `INFO` needs to be encoded as a bulk string.\n  - An example valid response would be `$11\\r\\nrole:master\\r\\n` (the string `role:master` encoded as a bulk string)\n"
    },
    {
      "slug": "hc6",
      "primary_extension_slug": "replication",
      "name": "The INFO command on a replica",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for the --replicaof arg and INFO command on the replica.\n",
      "description_md": "In this stage, you'll extend the [INFO](https://redis.io/commands/info/) command to reflect a server's role as a replica.\n\n### The `--replicaof` Flag\n\nBy default, your Redis server assumes the master role. When you pass the `--replicaof` flag, the server assumes the replica role instead.\n\nFor example:\n\n```\n./your_program.sh --port 6380 --replicaof \"localhost 6379\"\n```\n\nHere, we use the `--replicaof` flag to start a Redis server as a replica. The server will listen for connections on port `6380`, but it will also connect to a master (another Redis server) running on `localhost:6379` and replicate all its changes.\n\nWe'll learn more about how this replication works in later stages. \n\nFor this stage, your primary task is to update the `INFO replication` command handler to check the server's configuration:\n\n- If the user does not include the `--replicaof` flag, respond with `role:master`.\n- If the user includes the `--replicaof` flag, respond with `role:slave`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<MASTER_HOST> <MASTER_PORT>\"\n```\n\nIt will then send the `INFO` command with a `replication` argument to your server.\n\n```bash\n$ redis-cli -p <PORT> INFO replication\n```\n\nYour program should respond with a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings) where each line\nis a key-value pair separated by a colon (`:`). The tester will only look for the `role` key and assert that the value is `slave`.\n\n### Notes\n\n- Your program still needs to pass the previous stage tests, so if `--replicaof` isn't specified, you should default to the `master` role.\n- Just like the last stage, you only need to support the `role` key in the response for this stage. We'll add support for the other keys in later stages.\n- You don't need to actually connect to the master server specified via `--replicaof` in this stage. We'll get to that in later stages.\n"
    },
    {
      "slug": "xc1",
      "primary_extension_slug": "replication",
      "name": "Initial replication ID and offset",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for reading a key from an RDB file that contains a single key-value pair. You'll do this by implementing the `KEYS *` command.\n",
      "description_md": "In this stage, you'll extend your `INFO` command to return the `master_replid` and `master_repl_offset` values.\n\n### The Replication ID and Offset\n\nEvery Redis master maintains two key pieces of information for managing replication: the **replication ID** and the **replication offset**.\n\nThe replication ID is a large pseudo-random string. This ID identifies the current history of the master's dataset. When a master server boots for the first time or restarts, it resets its ID.\n\nThe replication offset tracks the number of bytes of commands the master has streamed to its replicas. This value is used to update the state of the replicas with changes made to the dataset. The offset starts at `0` when a master boots up and no replicas have connected yet.\n\nIn this stage, you'll initialize a replication ID and offset for the master server:\n\n- The ID can be any pseudo-random alphanumeric string of `40` characters.\n  - For this challenge, you don't need to generate a random string. You can hardcode it instead.\n  - As an example, you can hardcode `8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb` as the replication ID.\n- The offset should be `0`.\n\nThese two values should be returned as part of the `INFO` command output, under the `master_replid` and `master_repl_offset` keys, respectively.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send the `INFO` command with the `replication` option to your server.\n\n```bash\n$ redis-cli INFO replication\n```\n\nYour program should respond with a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings) where each line is a key-value pair separated by a colon (`:`). The tester will look for the following key-value pairs:\n\n- `role`: `master`\n- `master_replid`: A 40-character alphanumeric string\n- `master_repl_offset`: `0`\n\n### Notes\n\n- Your code must pass previous stage tests, meaning you should still return the correct `role` key.\n"
    },
    {
      "slug": "gl7",
      "primary_extension_slug": "replication",
      "name": "Send handshake (1/3)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for starting the handshake from the Replica side.\n",
      "description_md": "In this stage, you'll implement the first step of the replication handshake.\n\n### Handshake\n\nWhen a replica connects to a master, it needs to go through a \"handshake\" before receiving updates from the master.\n\nThere are three steps to this handshake:\n\n1. The replica sends a `PING` to the master.\n2. The replica sends `REPLCONF` twice to the master.\n3. The replica sends `PSYNC` to the master.\n\nWe'll learn more about `REPLCONF` and `PSYNC` in later stages. For now, we'll focus on the first part of the handshake.\n\nWhen your server starts in replica mode, it must connect to the specified master host and port, and then send the `PING` command.\n\nThe `PING` command must be sent encoded as a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<MASTER_HOST> <MASTER_PORT>\"\n```\n\nIt will then assert that the replica connects to the master and sends the `PING` command as a RESP array (`*1\\r\\n$4\\r\\nPING\\r\\n`).\n"
    },
    {
      "slug": "eh4",
      "primary_extension_slug": "replication",
      "name": "Send handshake (2/3)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for continuing the handshake from the Replica side, by sending REPLCONF.\n",
      "description_md": "In this stage, you'll implement the second step of the replication handshake.\n\n### Handshake (Recap)\n\nAs a recap, there are three steps to the handshake:\n\n1. The replica sends a `PING` to the master (Handled in the previous stage)\n2. The replica sends `REPLCONF` twice to the master\n3. The replica sends `PSYNC` to the master\n\nFor this stage, you'll handle the second step of this process.\n\n### The `REPLCONF` Command\n\nThe `REPLCONF` command is used to configure a connected replica. After receiving a response to `PING`, the replica sends two `REPLCONF` commands to the master:\n\n1. `REPLCONF listening-port <PORT>`: This tells the master which port the replica is listening on. This value is used for [monitoring and logging](https://github.com/redis/redis/blob/90178712f6eccf1e5b61daa677c5c103114bda3a/src/replication.c#L107-L130), not for replication itself.\n2. `REPLCONF capa psync2`: This notifies the master of the replica's capabilities.\n   - `capa` stands for \"capabilities\". It indicates that the next argument is a feature the replica supports.\n   - `psync2` signals that the replica supports the PSYNC2 protocol. PSYNC2 is an improved version of the [partial synchronization](https://redis.io/docs/latest/operate/oss_and_stack/management/replication/) feature used to resynchronize a replica with its master.\n   - You can safely hardcode `capa psync2` for now.\n\nBoth commands should be sent as RESP arrays, so the exact bytes will look something like this:\n\n```\n# REPLCONF listening-port <PORT>\n*3\\r\\n$8\\r\\nREPLCONF\\r\\n$14\\r\\nlistening-port\\r\\n$4\\r\\n6380\\r\\n\n\n# REPLCONF capa psync2\n*3\\r\\n$8\\r\\nREPLCONF\\r\\n$4\\r\\ncapa\\r\\n$6\\r\\npsync2\\r\\n\n```\n\nFor both commands, the master will respond with `+OK\\r\\n`. That's the string `OK` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<MASTER_HOST> <MASTER_PORT>\"\n```\n\nIt will then assert that the replica connects to the master and sends the following:\n\n1. The `PING` command\n2. The `REPLCONF` command with `listening-port` and `<PORT>` as the arguments\n3. The `REPLCONF` command with `capa psync2` as the arguments\n\n**Notes**\n\n- The response to `REPLCONF` will always be `+OK\\r\\n`.\n"
    },
    {
      "slug": "ju6",
      "primary_extension_slug": "replication",
      "name": "Send handshake (3/3)",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for finishing the handshake from the Replica side, by sending PSYNC.\n",
      "description_md": "In this stage, you'll implement the third step of the replication handshake.\n\n### Handshake (Recap)\n\nAs a recap, there are three steps to the handshake:\n\n- The replica sends a `PING` to the master (Handled in an earlier stage)\n- The replica sends `REPLCONF` twice to the master (Handled in the previous stage)\n- The replica sends `PSYNC` to the master\n\n### The `PSYNC` Command\n\nAfter receiving a response to the second `REPLCONF`, the replica sends a [`PSYNC`](https://redis.io/commands/psync/) command to the master. \n\nThe `PSYNC` command is used to synchronize the state of the replica with the master. The command format is:\n\n```bash\nPSYNC <replication_id> <offset>\n```\n\nThe command takes two arguments: the master's current replication ID and the replica's current offset.\n\nFor the replica's first connection to the master:\n\n- The replication ID will be `?` because the replica doesn't know the master's ID yet.\n- The offset will be `-1` since the replica has no data from the master yet.\n\nSo the final command sent will be `PSYNC ? -1`, encoded as a RESP array:\n\n```\n*3\\r\\n$5\\r\\nPSYNC\\r\\n$1\\r\\n?\\r\\n$2\\r\\n-1\\r\\n\n```\n\nThe master will respond with a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings) that looks like this:\n\n```\n+FULLRESYNC <REPL_ID> 0\\r\\n\n```\n\nYou can ignore this response for now. We'll get to handling it in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<MASTER_HOST> <MASTER_PORT>\"\n```\n\nIt will then assert that the replica connects to the master and sends the following commands:\n\n1. `PING`\n2. `REPLCONF` with `listening-port` and `<PORT>` as arguments\n3. `REPLCONF` with `capa psync2` as arguments\n4. `PSYNC` with `? -1` as arguments\n"
    },
    {
      "slug": "fj0",
      "primary_extension_slug": "replication",
      "name": "Receive handshake (1/2)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for starting the handshake from the master side, by accepting REPLCONF.\n",
      "description_md": "In this stage, we'll start implementing support for receiving a replication handshake as a master.\n\n### Handshake (Recap)\n\nUp until now, we've been implementing the handshake from the replica's perspective. Now we'll implement the same handshake on the master side.\n\nAs a recap, the master receives the following from the replica during the handshake:\n\n1. A `PING` command\n2. Two `REPLCONF` commands\n3. A `PSYNC` command\n\nYour Redis server already supports the `PING` command, so there's no additional work to do for the first step.\n\nIn this stage, you'll add support for receiving the two `REPLCONF` commands as a master.\n\nFor the purposes of this challenge, you can safely ignore the arguments for both commands and simply respond with `+OK\\r\\n`. That's the string `OK` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings)\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT>\n```\n\nIt will then send the following commands:\n\n1. `PING` — expecting `+PONG\\r\\n`\n2. `REPLCONF listening-port <PORT>` — expecting `+OK\\r\\n`\n3. `REPLCONF capa psync2` — expecting `+OK\\r\\n` \n"
    },
    {
      "slug": "vm3",
      "primary_extension_slug": "replication",
      "name": "Receive handshake (2/2)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for accepting PSYNC, and starting a FULLRESYNC.\n",
      "description_md": "In this stage, you'll add support for receiving the [`PSYNC`](https://redis.io/commands/psync/) command from the replica.\n\n### Handshake (Recap)\n\nAs a recap, the master receives the following for the handshake:\n\n1. A `PING` from the replica\n2. `REPLCONF` twice from the replica\n3. `PSYNC` from the replica\n\nAfter the replica sends `REPLCONF` twice, it will send a `PSYNC` command with the arguments `? -1` to the master:\n\n- The replication ID is `?` because the replica doesn't know the master's ID yet.\n- The offset is `-1` since the replica has no data from the master yet.\n\nThe final command you'll receive will look something like this:\n\n```\n*3\\r\\n$5\\r\\nPSYNC\\r\\n$1\\r\\n?\\r\\n$2\\r\\n-1\\r\\n\n```\n\nThat's `[\"PSYNC\", \"?\", \"-1\"]` encoded as a RESP array.\n\nThe master needs to respond with `+FULLRESYNC <REPL_ID> 0\\r\\n`, which is `FULLRESYNC <REPL_ID> 0` encoded as a simple string. Here's what the response means:\n\n- `FULLRESYNC` means that the master cannot perform an incremental update to the replica, and will start a full resynchronization.\n- `<REPL_ID>` is the replication ID of the master (the 40-character string you initialized in a previous stage).\n- `0` is the replication offset of the master (which you initialized in a previous stage).\n\nFor example, if your replication ID is `8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb`, you'd respond with:\n```bash\n+FULLRESYNC 8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb 0\\r\\n\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT>\n```\n\nIt will then connect to your TCP server as a replica and send the following commands:\n\n1. `PING` - expecting `+PONG\\r\\n` back\n2. `REPLCONF listening-port <PORT>` - expecting `+OK\\r\\n` back\n3. `REPLCONF capa psync2` - expecting `+OK\\r\\n` back\n4. `PSYNC ? -1` - expecting `+FULLRESYNC <REPL_ID> 0\\r\\n` back\n\n**Notes**:\n\n- In the response, `<REPL_ID>` needs to be replaced with the replication ID of the master, which you've initialized in previous stages.\n"
    },
    {
      "slug": "cf8",
      "primary_extension_slug": "replication",
      "name": "Empty RDB transfer",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for sending an empty RDB file to the replica. This is part of the \"full resynchronization\" process.\n",
      "description_md": "In this stage, you'll add support for sending an empty RDB file as a master. \n\n### Full Resynchronization\n\nWhen a replica connects to a master for the first time, it sends a `PSYNC ? -1` command. This is the replica's way of telling the master that it doesn't have any data yet and needs to be fully resynchronized.\n\nThe master responds in two steps:\n\n- It acknowledges with a `FULLRESYNC` response (Handled in a previous stage)\n- It sends a snapshot of its current state as an [RDB file](https://rdb.fnordig.de/file_format.html).\n\nThe replica is expected to load the file into memory and replace its current state with the master's data.\n\nFor this challenge, you don’t need to build an RDB file yourself. Instead, you can hardcode an empty RDB file, since we’ll assume the master’s database is always empty.\n\nYou can find the hex and base64 representation of an empty RDB file [here](https://github.com/codecrafters-io/redis-tester/blob/main/internal/assets/empty_rdb_hex.md). You need to decode these into binary contents before sending them to the replica.\n\nThe file is sent using the following format:\n\n```\n$<length_of_file>\\r\\n<binary_contents_of_file>\n```\n\nThis is similar to how [bulk strings](https://redis.io/topics/protocol#resp-bulk-strings) are encoded, but without the trailing `\\r\\n`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT>\n```\n\nIt will then connect to your TCP server as a replica and execute the following commands:\n\n1. `PING` - expecting `+PONG\\r\\n`\n2. `REPLCONF listening-port <PORT>` - expecting `+OK\\r\\n`\n3. `REPLCONF capa eof capa psync2` - expecting `+OK\\r\\n`\n4. `PSYNC ? -1` - expecting `+FULLRESYNC <REPL_ID> 0\\r\\n`\n\nAfter the last response, the tester will expect to receive an empty RDB file from your server.\n\nThe tester will accept any valid RDB file that is empty.\n\n### Notes\n\n- The RDB file should be sent like this: `$<length>\\r\\n<contents>`\n  - `<length>` is the length of the file in bytes\n  - `<contents>` is the binary contents of the file\n  - Note that this is NOT a RESP bulk string and doesn't contain a `\\r\\n` at the end.\n- If you want to learn more about the RDB file format, read [this blog post](https://rdb.fnordig.de/file_format.html). This challenge\n  has a separate extension dedicated to reading RDB files.\n"
    },
    {
      "slug": "zn8",
      "primary_extension_slug": "replication",
      "name": "Single-replica propagation",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for finishing the sync handshake from the master side, by sending a RDB file.\n",
      "description_md": "In this stage, you'll add support for propagating write commands to a single replica as a master.\n\n### Command Propagation\n\nAfter the replication handshake is complete and the master has sent the RDB file to the replica, the master starts propagating \"write\" commands to the replica.\n\nWrite commands are commands that modify the master's dataset, such as `SET` and `DEL`. Commands like `PING`, `ECHO`, etc., are not considered \"write\" commands, so they aren't propagated.\n\n### The Propagation Process\n\nCommand propagation happens over the replication connection. This is the same connection that was used for the handshake.\n\nThe propagated commands are sent as RESP arrays. For example, if the master receives `SET foo bar` as a command from a client, it'll send `*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n` to all connected replicas over their respective replication connections.\n\nReplicas process commands received over the connection just like they would process commands received from a client, but with one difference: they don't send responses back to the master. They just process the command silently and update their state.\n\nSimilarly, the master doesn't wait for a response from the replica when propagating commands. It just sends the commands as they come in.\n\nThere is one exception to this \"no response\" rule: the `REPLCONF GETACK` command. We'll learn about this command in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT>\n```\n\nIt will then connect to your TCP server as a replica and complete the full handshake sequence covered in previous stages.\n\nThe tester will then wait for your server to send an RDB file.\n\nOnce the RDB file is received, the tester will send a series of write commands to your program (as a separate Redis client).\n\n```bash\n$ redis-cli SET foo 1\n$ redis-cli SET bar 2\n$ redis-cli SET baz 3\n```\n\nIt will then assert that these commands were propagated to the replica in the correct order. The tester will expect to receive these commands: \n\n- Encoded as RESP arrays.\n- Sent on the same connection used for the handshake (replication connection).\n\n### Notes\n\n- Although replicas provide a `listening-port` during the handshake, it’s used only for [monitoring/logging purposes](https://github.com/redis/redis/blob/90178712f6eccf1e5b61daa677c5c103114bda3a/src/replication.c#L107-L130), not for propagation. Redis propagates commands over the same TCP connection that the replica initiated during the handshake.\n- A true implementation would buffer the commands so that they can be sent to the replica after it loads the RDB file. For the purposes of this challenge, you can assume that the replica is ready to receive commands immediately after receiving the RDB file.\n"
    },
    {
      "slug": "hd5",
      "primary_extension_slug": "replication",
      "name": "Multi-replica propagation",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll complete your implementation of Redis replication.\n",
      "description_md": "In this stage, you'll extend your implementation of the master to support propagating commands to multiple replicas.\n\n### Command Propagation (Recap)\n\nOnce a replica completes the handshake and loads the RDB file, it is ready to start receiving live updates from the master. \n\nEvery write command executed on the master must be forwarded to all connected replicas, not just one. This ensures that every replica stays in sync with the master.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT>\n```\n\nIt will then start **multiple** replicas that will each connect to your server, complete the handshake, and receive the initial RDB file.\n\nNext, the tester will send `SET` commands to the master from a separate client.\n\n```bash\n$ redis-cli SET foo 1\n$ redis-cli SET bar 2\n$ redis-cli SET baz 3\n```\n\nIt will then assert that each replica received those commands in the correct order.\n"
    },
    {
      "slug": "yg4",
      "primary_extension_slug": "replication",
      "name": "Command processing",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll add support for processing commands received by the replica from the master.\n",
      "description_md": "In this stage, you'll implement the processing of propagated commands as a replica.\n\n### Command Processing\n\nAfter the replica receives a command from the master, it processes it and applies it to its own state. This will work exactly like a regular command sent by a client. The key difference is that the replica **must not send a response** back to the master.\n\nFor example, if a master propagates `SET foo 1` to a replica:\n\n- The replica must update its database to set the value of `foo` to `1`.\n- Unlike commands from regular clients, the replica does not reply with `+OK\\r\\n`.\n\n### Tests\n\nThe tester will spawn a Redis master and execute your program as a replica like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<MASTER_HOST> <MASTER_PORT>\"\n```\n\nJust like in the previous stages, your replica should complete the handshake with the master and receive an empty RDB file.\n\nOnce the RDB file is received, the master will propagate a series of write commands to your program:\n\n```bash\nSET foo 1 # propagated from master to replica\nSET bar 2 # propagated from master to replica\nSET baz 3 # propagated from master to replica\n```\n\nThe tester will then issue `GET` commands to your program to check if the commands were processed correctly.\n\n```bash\n$ redis-cli GET foo # expecting `1` back\n$ redis-cli GET bar # expecting `2` back\n# ... and so on\n```\n\n### Notes\n\n- The propagated commands are sent as RESP arrays. So the command `SET foo 1` will be sent as `*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$1\\r\\n1\\r\\n`.\n- It is **not** guaranteed that propagated commands will be sent one at a time. One TCP segment might contain bytes for multiple commands.\n"
    },
    {
      "slug": "xv6",
      "primary_extension_slug": "replication",
      "name": "ACKs with no commands",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for returning an ACK back to master as a response to GETACK.\n",
      "description_md": "In this stage, you'll implement support for responding to the `REPLCONF GETACK` command as a replica.\n\n### ACKs\n\nNormally, a replica processes propagated commands silently. However, the master needs a way to verify that a replica is \"in sync\" and hasn't fallen behind. This is done using ACKs (acknowledgements).\n\nRedis masters periodically ask replicas to send ACKs to check how much of the replication stream they’ve processed.\n\n### The `REPLCONF GETACK` command\n\nWhen the master wants an update, it sends the command:\n\n```bash\nREPLCONF GETACK *\n```\n\nThe exact command received by the replica will look something like this: `*3\\r\\n$8\\r\\nreplconf\\r\\n$6\\r\\ngetack\\r\\n$1\\r\\n*\\r\\n`. That's `[\"replconf\", \"getack\", \"*\"]` encoded as a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays).\n\nThe replica receives this command over the replication connection (i.e., the connection used for the replication handshake) and responds with:\n\n```bash\nREPLCONF ACK <offset>\n```\n\nThe offset is the number of bytes of commands processed by the replica. For this stage, you can hardcode the offset to `0`. We'll learn how to track offsets and update them in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<HOST> <PORT>\"\n```\n\nJust like in the previous stages, your replica should complete the handshake with the master and receive an empty RDB file.\n\nThe tester will then send `REPLCONF GETACK *` to your replica. \n\nIt will expect to receive `REPLCONF ACK 0` encoded as a RESP array (`*3\\r\\n$8\\r\\nREPLCONF\\r\\n$3\\r\\nACK\\r\\n$1\\r\\n0\\r\\n`).\n\n### Notes\n\n- After the master-replica handshake is complete, a replica should **only** send responses to `REPLCONF GETACK` commands. All other propagated commands (like `PING`, `SET`, etc.) should be read and processed, but a response should not be sent back to the master.\n"
    },
    {
      "slug": "yd3",
      "primary_extension_slug": "replication",
      "name": "ACKs with commands",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for returning an ACK back to master as a response to GETACK.\n",
      "description_md": "In this stage, you'll extend your `REPLCONF GETACK` implementation to respond with the number of bytes of commands processed by the replica.\n\n### ACKs (Recap)\n\nAs a recap, a master uses ACKs to verify that its replicas are in sync with it and haven't fallen behind. Each ACK contains an offset — the number of bytes of commands processed by the replica.\n\n### Offset tracking\n\nA replica keeps its offset updated by tracking the total byte size of every command received from its master. This includes both write commands (like `SET`, `DEL`) and non-write commands (like `PING`, `REPLCONF GETACK *`).\n\nAfter processing the received command (e.g., `[\"SET\", \"foo\", \"bar]`), it adds the full RESP array byte length to its running offset.\n\nAn important rule for this process is that the offset should only include commands processed **before** the current `REPLCONF GETACK *` request.\n\nFor example:\n\n- A replica connects, completes the handshake, and the master sends `REPLCONF GETACK *`.\n  - The replica responds with `REPLCONF ACK 0` since no commands had been processed before this request.\n- Next, the master sends another `REPLCONF GETACK *`.\n  - The replica responds with `REPLCONF ACK 37`, because the previous `REPLCONF` command consumed 37 bytes.\n- The master then sends a `PING` command.\n  - The replica silently processes it, increments its offset by 14, and sends no response.\n- The next `REPLCONF GETACK *` arrives.\n  - The replica responds with `REPLCONF ACK 88` — that’s 37 (for the first `REPLCONF`), +37 (for the second `REPLCONF`), +14 (for the `PING`).\n\nNotice that the current `GETACK` request itself is not included in the offset value.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh --port <PORT> --replicaof \"<HOST> <PORT>\"\n```\n\nJust like in the previous stages, your replica should complete the handshake with the master and receive an empty RDB file.\n\nThe master will then propagate a series of commands to your replica. These commands will be interleaved with `REPLCONF GETACK *` commands.\n\n```bash\nREPLCONF GETACK *    # expect: REPLCONF ACK 0\n\nPING                 # replica processes silently\nREPLCONF GETACK *    # expect: REPLCONF ACK 51\n# 51 = 37 (first REPLCONF) + 14 (PING)\n\nSET foo 1             # replica processes silently\nSET bar 2             # replica processes silently\nREPLCONF GETACK *    # expect: REPLCONF ACK 146\n# 146 = 51 + 37 (second REPLCONF) + 29 (SET foo) + 29 (SET bar)\n```\n\nYour replica must calculate and return the exact offset at each step in the `REPLCONF ACK <offset>` response. Your response should also be encoded as a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays).\n\n### Notes\n\n- The offset should only include the number of bytes of commands processed **before** receiving the current `REPLCONF GETACK` command.\n- Although masters don't propagate `PING` commands when received from clients (since they aren't \"write\" commands), they may send `PING` commands to replicas to notify replicas that the master is still alive.\n"
    },
    {
      "slug": "my8",
      "primary_extension_slug": "replication",
      "name": "WAIT with no replicas",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll start implementing the WAIT command on your master.\n",
      "description_md": "In this stage, you’ll implement support for the `WAIT` command on the master.\n\n### The `WAIT` command\n\nThe `WAIT` command is used to check how many replicas have acknowledged a write command. This allows a client to measure the durability of a write command before considering it successful.\n\nThe command format is: \n\n```bash\nWAIT <numreplicas> <timeout>\n```\n\nHere's what each argument means:\n\n- `<numreplicas>`: The minimum number of replicas that must acknowledge the write command.\n- `<timeout>`: The maximum time (in milliseconds) the client is willing to wait.\n\nFor example:\n\n```bash\n$ redis-cli WAIT 3 5000\n(integer) 2\n```\n\nHere, the client is asking the master to wait for `3` replicas (with a maximum timeout of 5000 ms). After the timeout passes, the master has only `2` replicas connected, so it immediately replies with `2` as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\nFor now, we’ll handle the simplest case: when the client needs `0` replicas and the master also has no replicas connected. In this case, `WAIT` should immediately return `0`.\n\nWe'll get to tracking the number of replicas and responding accordingly in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then connect to your master and send:\n\n```bash\n$ redis-cli WAIT 0 60000\n```\n\nThe tester will expect to receive `0` immediately (as a RESP integer), since no replicas are connected.\n"
    },
    {
      "slug": "tu8",
      "primary_extension_slug": "replication",
      "name": "WAIT with no commands",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll continue implementing the WAIT command on your master.\n",
      "description_md": "In this stage, you’ll extend your `WAIT` implementation to handle the case where replicas are connected, but no commands have been sent.\n\n### `WAIT` with connected replicas\n\nIn a previous stage, we handled the case where no replicas were connected, and the master could safely return `0`.\n\nNow, we’ll consider the case where some replicas are connected. Each replica will have completed the handshake and received the empty RDB file. But since no write commands have been sent yet, the replication offset is still `0`.\n\nIn this situation, the master will return the number of connected replicas, since it knows they are all in sync at offset `0`:\n\n```bash\n$ redis-cli WAIT 3 500\n(integer) 7\n$ redis-cli WAIT 7 500\n(integer) 7\n$ redis-cli WAIT 9 500\n(integer) 7\n```\n\nIn the example above, `7` replicas are connected. No matter how many replicas the client asks for, the master will reply with the number of connected replicas (`7`).\n\nFor this stage, you can ignore both arguments (`<numreplicas> <timeout>`) and simply return the number of connected replicas.\n\n### Tests\n\nThe tester will execute your program as a master like this:\n\n```\n./your_program.sh\n```\n\nIt will then start **multiple** replicas that connect to your server. Each will complete the handshake and expect to receive an empty RDB file.\n\nIt will then connect to your master as a client and send commands like this:\n\n```bash\n$ redis-cli WAIT 3 500 # (expecting 7 back)\n$ redis-cli WAIT 7 500 # (expecting 7 back)\n$ redis-cli WAIT 9 500 # (expecting 7 back)\n```\n\nThe response to each of these commands should be encoded as a RESP integer (i.e., `:7\\r\\n`).\n\n### Notes\n\n- Even if `WAIT` is called with a number less than the number of connected replicas, the master should return the count of connected replicas.\n- The number of replicas created in this stage will be random, so you can't hardcode `7` as the response, like in the example above.\n"
    },
    {
      "slug": "na2",
      "primary_extension_slug": "replication",
      "name": "WAIT with multiple commands",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll finish implementing the WAIT command on your master.\n",
      "description_md": "In this stage, you’ll extend your `WAIT` implementation to handle the case where replicas are connected and have received write commands.\n\n### `WAIT` with propagated commands\n\nIn previous stages, we handled the cases where:\n- No replicas were connected, and the master could safely return `0`.\n- Replicas were connected, but hadn't received any write commands.\n\nNow, we’ll handle the case where write commands have been sent to replicas. Since replication offsets are no longer `0`, the master needs to check which replicas have successfully processed the latest write command before replying.\n\nTo do this, the master must send `REPLCONF GETACK *` to replicas if there are pending write commands since the last `WAIT`. Each replica will reply with its current offset (`REPLCONF ACK <offset>`).\n\nThe `WAIT` command should complete when either:\n\n- The required number of replicas has acknowledged the last write command, or\n- The timeout expires.\n\nEither way, the master should return the number of replicas that acknowledged the command as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\n### Tests\n\nThe tester will execute your program as a master like this:\n\n```\n./your_program.sh\n```\n\nIt will then start **multiple** replicas that connect to your server. Each will complete the handshake and expect to receive an empty RDB file.\n\nNext, the tester will connect to your master as a client and send multiple write commands interleaved with `WAIT` commands:\n\n```bash\n$ redis-cli SET foo 123\n$ redis-cli WAIT 1 500    # (must wait until either 1 replica has processed previous commands or 500ms have passed)\n\n$ redis-cli SET bar 456\n$ redis-cli WAIT 2 500    # (must wait until either 2 replicas have processed previous commands or 500ms have passed)\n```\n\n### Notes\n\n- The returned number of replicas might be less than or greater than the expected number of replicas specified in the `WAIT` command.\n"
    },
    {
      "slug": "cc3",
      "primary_extension_slug": "streams",
      "name": "The TYPE command",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for the `TYPE` command.\n",
      "description_md": "In this stage, you'll add support for the `TYPE` command.\n\n### The `TYPE` command\n\nThe [TYPE](https://redis.io/commands/type/) command returns the type of value stored at a given key. These types include: `string`, `list`, `set`, `zset`, `hash`, `stream`, and `vectorset`.\n\nHere's an example:\n\n```bash\n# Set a key to a string value\n$ redis-cli SET some_key \"foo\"\n\"OK\"\n\n# Check the type of value at the key\n$ redis-cli TYPE some_key\n\"string\"\n```\n\nThe return value is encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\nIf a key doesn't exist, the return value will be `none`.\n\n```bash\n$ redis-cli TYPE missing_key\n\"none\"\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `SET` command to your server to create a key with a string value.\n\n```bash\n$ redis-cli SET some_key \"foo\"\n```\n\nNext, it will send a `TYPE` command for that key.\n\n```bash\n$ redis-cli TYPE some_key\n```\n\nYour server should respond with `+string\\r\\n`, which is `string` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\nNext, the tester will send another `TYPE` command with a missing key.\n\n```bash\n$ redis-cli TYPE missing_key\n```\n\nYour server should respond with `+none\\r\\n`, which is `none` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\n### Notes\n\n- For now, you only need to handle the `string` and `none` types. We'll add support for the `stream` type in the next stage.\n"
    },
    {
      "slug": "cf6",
      "primary_extension_slug": "streams",
      "name": "Create a stream",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for creating a [Redis stream](https://redis.io/docs/latest/develop/data-types/streams/) using the `XADD` command.\n",
      "description_md": "In this stage, you'll add support for creating [Redis streams](https://redis.io/docs/latest/develop/data-types/streams/) using the `XADD` command.\n\n### Redis Streams & Entries\n\nA [Redis stream](https://redis.io/docs/latest/develop/data-types/streams/) is used to store a sequence of entries in chronological order at a given key. Each entry consists of a unique ID and one or more key-value pairs.\n\nFor example, if you were using a Redis stream to store real-time data from a temperature & humidity monitor, the stream might look like this:\n\n```yaml\nentries:\n  - id: 1526985054069-0 # (ID of the first entry)\n    temperature: 36 # (A key-value pair in the first entry)\n    humidity: 95 # (Another key-value pair)\n\n  - id: 1526985054079-0 # (ID of the second entry)\n    temperature: 37 # (A key-value pair in the second entry)\n    humidity: 94 # (Another key-value pair)\n\n  # ... (and so on)\n```\n\nWe’ll take a closer look at how entry IDs (like `1526985054069-0`) are structured in later stages.\n\n### The `XADD` command\n\nThe [`XADD`](https://redis.io/commands/xadd/) command appends an entry to a stream. If the stream doesn't exist, it is created automatically.\n\nThe `XADD` command accepts a stream key, an entry ID, and one or more key-value pairs as arguments:\n\n```bash\n$ redis-cli XADD stream_key 1526919030474-0 temperature 36 humidity 95\n\"1526919030474-0\"\n```\n\nThe return value is the ID of the newly added entry as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\n`XADD` supports other [optional arguments](https://redis.io/docs/latest/commands/xadd/#optional-arguments), but we won't deal with them in this challenge.\n\n`XADD` also supports auto-generated entry IDs, but for this stage, you'll only deal with explicit IDs (like `1526919030474-0`).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt'll then send an `XADD` command to your server and expect the ID as a response. For example, it might send:\n\n```bash\n$ redis-cli XADD stream_key 0-1 foo bar\n\"0-1\"\n```\n\nIn this case, your server should respond with `$3\\r\\n0-1\\r\\n`, which is `0-1` encoded as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\nNext, the tester will send a `TYPE` command to your server to verify the key's type.\n\n```bash\n$ redis-cli TYPE stream_key\n\"stream\"\n```\n\nYour server should respond with `+stream\\r\\n`, which is `stream` encoded as a [simple string](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings).\n\n### Notes\n\n- You still need to handle the `string` and `none` return values for the `TYPE` command. `stream` should only be returned for keys that are streams.\n"
    },
    {
      "slug": "hq8",
      "primary_extension_slug": "streams",
      "name": "Validating entry IDs",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll enhance the `XADD` command by extending support for explicit IDs.\n",
      "description_md": "In this stage, you'll add support for validating entry IDs to the `XADD` command.\n\n### Entry IDs\n\nEntry IDs are crucial for maintaining the order of entries in Redis streams.\n\nEach ID is made up of two integers separated by a dash: `<millisecondsTime>-<sequenceNumber>`.\n\nHere's an example from the previous stage:\n\n```yaml\nentries:\n  - id: 1526985054069-0 # (ID of the first entry)\n    temperature: 36\n    humidity: 95\n\n  - id: 1526985054079-0 # (ID of the second entry)\n    temperature: 37\n    humidity: 94\n\n  # ... (and so on)\n```\n\nThese IDs are unique within a stream and are guaranteed to be incremental. This means a new entry's ID will always be greater than the ID of any previous entry.\n\n### Specifying Entry IDs in `XADD`\n\nYou can use three different formats to specify the ID for the `XADD` command:\n\n- Explicit (`1526919030474-0`)\n- Auto-generate only sequence number (`1526919030474-*`)\n- Auto-generate the time and sequence number (`*`)\n\nFor this stage, you will only handle explicit IDs (e.g., `1526919030474-0`). You'll add support for the other two cases in the next stages.\n\nYour `XADD` implementation must validate the provided ID based on the following rules:\n\n- The ID must be strictly greater than the last entry's ID.\n  - The `millisecondsTime` portion of the new ID must be greater than or equal to the last entry's `millisecondsTime`.\n  - If the `millisecondsTime` values are equal, the `sequenceNumber` of the new ID must be greater than the last entry's `sequenceNumber`.\n- If the stream is empty, the ID must be greater than `0-0`. The minimum valid ID Redis accepts is `0-1`.\n\nHere's an example of adding an entry with a valid ID followed by an invalid ID:\n\n```bash\n$ redis-cli XADD some_key 1-1 foo bar\n\"1-1\"\n$ redis-cli XADD some_key 1-1 bar baz\n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n```\n\nThe second command fails because `1-1` is not strictly greater than the last ID.\n\nHere's another example:\n\n```bash\n$ redis-cli XADD some_key 1-1 foo bar\n\"1-1\"\n$ redis-cli XADD some_key 0-2 bar baz\n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n```\n\nThe ID `0-2` is invalid because its `millisecondsTime` is less than the last ID's `millisecondsTime`.\n\nFinally, passing `0-0` is always invalid, since IDs must be strictly greater than `0-0`:\n\n```bash\n$ redis-cli XADD some_key 0-0 bar baz\n(error) ERR The ID specified in XADD must be greater than 0-0\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then create a few entries using `XADD`.\n\n```bash\n$ redis-cli XADD stream_key 1-1 foo bar\n\"1-1\"\n$ redis-cli XADD stream_key 1-2 bar baz\n\"1-2\"\n```\n\nNext, it will send a few `XADD` commands with an invalid ID, such as `1-2` or `0-3`. \n\n```bash\n# The exact time and sequence number as the last entry\n$ redis-cli XADD stream_key 1-2 baz foo\n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n\n# A smaller value for the time and a larger value for the sequence number\n$ redis-cli XADD stream_key 0-3 baz foo\n(error) ERR The ID specified in XADD is equal or smaller than the target stream top item\n```\n\nIn each case, your server should respond with `-ERR The ID specified in XADD is equal or smaller than the target stream top item\\r\\n\\`, encoded as a\n[simple error](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-errors).\n\nAfter that, the tester will send another `XADD` command with `0-0` as the ID.\n\n```bash\n$ redis-cli XADD stream_key 0-0 baz foo\n(error) ERR The ID specified in XADD must be greater than 0-0\n```\n\nYour server should respond with `-ERR The ID specified in XADD must be greater than 0-0\\r\\n`, which is the error message above encoded as a\n[simple error](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-errors).\n"
    },
    {
      "slug": "yh3",
      "primary_extension_slug": "streams",
      "name": "Partially auto-generated IDs",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll enhance the `XADD` command by adding the option to use `*` as the sequence number.\n",
      "description_md": "In this stage, you'll extend `XADD` to support auto-generating the sequence number of an entry ID.\n\n### Specifying Entry IDs in `XADD` (Recap)\n\nAs a recap, the `XADD` command accepts IDs in three formats:\n\n- Explicit (`1526919030473-0`) (Handled in the previous stage)\n- Auto-generate only the sequence number (`1526919030474-*`)\n- Auto-generate the time part and sequence number (`*`)\n\nFor this stage, you'll handle the second case, where only the sequence number is auto-generated.\n\n### Auto-Generating Sequence Numbers\n\nRedis automatically assigns sequence numbers based on the following conditions:\n\n- If the stream is empty for a given time part, the sequence number starts at `0`.\n- If there are already entries with the same time part, the new sequence number is the last sequence number plus `1`.\n- The only exception is when the time part is `0`. In that case, the default sequence number starts at `1`.\n\nHere's an example of adding an entry with `*` as the sequence number:\n\n```bash\n$ redis-cli XADD some_key \"1-*\" foo bar\n\"1-0\" # The sequence number is 0 if no prior entries exist\n\n$ redis-cli XADD some_key \"1-*\" bar baz\n\"1-1\" # Adding another entry will increment the sequence number\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send an `XADD` command with `*` as the sequence number.\n\n```bash\n$ redis-cli XADD stream_key 0-* foo bar\n```\n\nYour server should respond with `$3\\r\\n0-1\\r\\n`, which is `0-1` encoded as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\nNext, it will send another `XADD` command with `*` as the sequence number, but this time with a random number as the time part.\n\n```bash\n$ redis-cli XADD stream_key 5-* foo bar\n```\n\nYour server should respond with `$3\\r\\n5-0\\r\\n`, which is `5-0` encoded as a bulk string.\n\nAfter that, the tester will send the same command again.\n\n```bash\n$ redis-cli XADD stream_key 5-* bar baz\n```\n\nYour server should respond with `$3\\r\\n5-1\\r\\n`, which is `5-1` encoded as a bulk string.\n\n### Notes\n\n- The tester will use a random number for the time part (we use `5` in the example above).\n"
    },
    {
      "slug": "xu6",
      "primary_extension_slug": "streams",
      "name": "Fully auto-generated IDs",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll enhance the `XADD` command by adding the option to use `*` as the entry ID.\n",
      "description_md": "In this stage, you'll extend `XADD` to support auto-generating entry IDs.\n\n### Specifying Entry IDs in `XADD` (Recap)\n\nAs a recap, the `XADD` command accepts IDs in three formats:\n\n- Explicit (`1526919030473-0`) (Handled in an earlier stage)\n- Auto-generate only the sequence number (`1526919030474-*`) (Handled in the previous stage)\n- Auto-generate the time part and sequence number (`*`)\n\nFor this stage, you'll handle the third case, where the entire entry ID is auto-generated.\n\n### Auto-Generating Entry IDs\n\nWhen `*` is used with the `XADD` command, the server automatically generates a unique ID for the new entry:\n\n- It uses the current Unix time in milliseconds for the time part and `0` for the sequence number.\n- If an entry with the same timestamp already exists in the stream, the server increments the sequence number by `1`.\n\nHere's an example:\n\n```bash\n> XADD stream_key * foo bar\n\"1526919030474-0\"\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then create an entry with `*` as the ID.\n\n```bash\n$ redis-cli XADD stream_key * foo bar\n```\n\nYour server should respond with a string like `$15\\r\\n1526919030474-0\\r\\n`, which is `1526919030474-0` encoded as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\n### Notes\n\n- The time part of the ID should be the current Unix time in **milliseconds**, not seconds.\n- The tester doesn't test the case where a time part already exists in the stream and the sequence number is incremented. This is difficult to test reliably since we'd need to send two commands within the same millisecond.\n"
    },
    {
      "slug": "zx1",
      "primary_extension_slug": "streams",
      "name": "Query entries from stream",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for querying data from a stream using the `XRANGE` command.\n",
      "description_md": "In this stage, you'll add support for querying data from a stream using the `XRANGE` command.\n\n### The `XRANGE` command\n\nThe [`XRANGE`](https://redis.io/docs/latest/commands/xrange/) command retrieves a range of entries from a stream.\n\nIt takes two arguments: a `start` ID and an `end` ID, and returns all entries within that range. The range is inclusive, meaning entries with IDs equal to the `start` and `end` IDs are included.\n\nHere's an example of how it works:\n\n```bash\n$ redis-cli XADD some_key 1526985054069-0 temperature 36 humidity 95\n\"1526985054069-0\" # (ID of the first added entry)\n$ redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n$ redis-cli XRANGE some_key 1526985054069 1526985054079\n1) 1) 1526985054069-0\n   2) 1) temperature\n      2) 36\n      3) humidity\n      4) 95\n2) 1) 1526985054079-0\n   2) 1) temperature\n      2) 37\n      3) humidity\n      4) 94\n```\n\nThe command can accept IDs in the format `<millisecondsTime>-<sequenceNumber>`, but the sequence number is optional. If you don't provide a sequence number:\n\n- For the `start` ID, the sequence number defaults to `0`.\n- For the `end` ID, the sequence number defaults to the maximum sequence number.\n\nThe return value of the command is not exactly what is shown in the example above. This is already formatted by redis-cli.\n\nThe actual return value is a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays) of arrays.\n\nEach inner array represents a single entry and contains two elements:\n\n- The entry's ID (as a [bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings)).\n- An array of key-value pairs (as bulk strings) in the order they were added.\n\nThe return value of the example above is actually something like this:\n\n```json\n[\n  [\n    \"1526985054069-0\",\n    [\n      \"temperature\",\n      \"36\",\n      \"humidity\",\n      \"95\"\n    ]\n  ],\n  [\n    \"1526985054079-0\",\n    [\n      \"temperature\",\n      \"37\",\n      \"humidity\",\n      \"94\"\n    ]\n  ],\n]\n```\n\nWhen encoded as a RESP array, it looks like this:\n\n```text\n*2\\r\\n\n*2\\r\\n\n$15\\r\\n1526985054069-0\\r\\n\n*4\\r\\n\n$11\\r\\ntemperature\\r\\n\n$2\\r\\n36\\r\\n\n$8\\r\\nhumidity\\r\\n\n$2\\r\\n95\\r\\n\n*2\\r\\n\n$15\\r\\n1526985054079-0\\r\\n\n*4\\r\\n\n$11\\r\\ntemperature\\r\\n\n$2\\r\\n37\\r\\n\n$8\\r\\nhumidity\\r\\n\n$2\\r\\n94\\r\\n\n```\n*(This response is separated into multiple lines for readability. The actual return value doesn't contain any additional newlines.)*\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then add a few entries to a stream.\n\n```bash\n$ redis-cli XADD stream_key 0-1 foo bar\n\"0-1\"\n$ redis-cli XADD stream_key 0-2 bar baz\n\"0-2\"\n$ redis-cli XADD stream_key 0-3 baz foo\n\"0-3\"\n```\n\nNext, it will send an `XRANGE` command to your server.\n\n```bash\n$ redis-cli XRANGE stream_key 0-2 0-3\n```\n\nYour server should respond with a RESP array containing the range of entries from the IDs provided. \n\nBased on the example above, the response should look like the following (encoded as a RESP array):\n\n```json\n[\n  [\n    \"0-2\",\n    [\n      \"bar\",\n      \"baz\"\n    ]\n  ],\n  [\n    \"0-3\",\n    [\n      \"baz\",\n      \"foo\"\n    ]\n  ]\n]\n```\n"
    },
    {
      "slug": "yp1",
      "primary_extension_slug": "streams",
      "name": "Query with -",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll extend support for `XRANGE` to allow querying using `-`.\n",
      "description_md": "In this stage, you'll extend support for `XRANGE` to allow querying using `-`.\n\n### Using `XRANGE` with `-`\n\nIn the `XRANGE` command, the `start` argument can be specified as `-` to retrieve entries from the very beginning of the stream. This provides a simple way to get a range of entries starting from the first one without needing to know its ID.\n\nHere's an example of how that works:\n\n```bash\n$ redis-cli XADD some_key 1526985054069-0 temperature 36 humidity 95\n\"1526985054069-0\"\n\n$ redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n\n$ redis-cli XRANGE some_key - 1526985054079\n1) 1) 1526985054069-0\n   2) 1) temperature\n      2) 36\n      3) humidity\n      4) 95\n2) 1) 1526985054079-0\n   2) 1) temperature\n      2) 37\n      3) humidity\n      4) 94\n```\n\nIn the example above, `XRANGE` retrieves all entries from the beginning of the stream to the entry with ID `1526985054079-0`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then create a few entries.\n\n```bash\n$ redis-cli XADD stream_key 0-1 foo bar\n\"0-1\"\n$ redis-cli XADD stream_key 0-2 bar baz\n\"0-2\"\n$ redis-cli XADD stream_key 0-3 baz foo\n\"0-3\"\n```\n\nNext, it will send an `XRANGE` command using `-` as the `start` ID:\n\n```bash\n$ redis-cli XRANGE stream_key - 0-2\n1) 1) 0-1\n   2) 1) foo\n      2) bar\n2) 1) 0-2\n   2) 1) bar\n      2) baz\n```\n\nYour server should respond with a RESP array containing the entries from the beginning of the stream up to the entry with the provided `end` ID.\n\nFrom the example above, the response should look like the following, encoded as a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays):\n\n```json\n[\n  [\n    \"0-1\",\n    [\n      \"foo\",\n      \"bar\"\n    ]\n  ],\n  [\n    \"0-2\",\n    [\n      \"bar\",\n      \"baz\"\n    ]\n  ]\n]\n```\n"
    },
    {
      "slug": "fs1",
      "primary_extension_slug": "streams",
      "name": "Query with +",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll extend support for `XRANGE` to allow querying using `+`.\n",
      "description_md": "In this stage, you'll extend support for `XRANGE` to allow querying using `+`.\n\n### Using `XRANGE` with `+`\n\nIn the `XRANGE` command, the `end` argument can be specified as `+` to retrieve entries from the given `start` ID to the end of the stream.\n\nHere's an example of how that works:\n\n```bash\n$ redis-cli XADD some_key 1526985054069-0 temperature 36 humidity 95\n\"1526985054069-0\"\n\n$ redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n\n$ redis-cli XRANGE some_key 1526985054069 +\n1) 1) 1526985054069-0\n   2) 1) temperature\n      2) 36\n      3) humidity\n      4) 95\n2) 1) 1526985054079-0\n   2) 1) temperature\n      2) 37\n      3) humidity\n      4) 94\n```\n\nIn the example above, `XRANGE` retrieves all the entries from `some_key` starting from the entry with ID `1526985054069-0` to the very end of the stream.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then create a few entries.\n\n```bash\n$ redis-cli XADD stream_key 0-1 foo bar\n$ redis-cli XADD stream_key 0-2 bar baz\n$ redis-cli XADD stream_key 0-3 baz foo\n```\n\nNext, it will send an `XRANGE` command using `+` as the `end` ID:\n\n```bash\n$ redis-cli XRANGE stream_key 0-2 +\n```\n\nYour server should respond with a RESP array containing the entries from the provided `start` ID to the end of the stream.\n\nFrom the example above, your response should look like the following, encoded as a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays):\n\n```json\n[\n  [\n    \"0-2\",\n    [\n      \"bar\",\n      \"baz\"\n    ]\n  ],\n  [\n    \"0-3\",\n    [\n      \"baz\",\n      \"foo\"\n    ]\n  ]\n]\n```\n\nThe raw RESP encoding looks like this:\n\n```text\n*2\\r\\n\n*2\\r\\n\n$3\\r\\n0-2\\r\\n\n*2\\r\\n\n$3\\r\\nbar\\r\\n\n$3\\r\\nbaz\\r\\n\n*2\\r\\n\n$3\\r\\n0-3\\r\\n\n*2\\r\\n\n$3\\r\\nbaz\\r\\n\n$3\\r\\nfoo\\r\\n\n```\n\n### Notes\n- In the response, the items are shown in separate lines for readability. The tester expects all of these to be in one line.\n"
    },
    {
      "slug": "um0",
      "primary_extension_slug": "streams",
      "name": "Query single stream using XREAD",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support to querying a stream using the `XREAD` command.\n",
      "description_md": "In this stage, you'll add support to querying a stream using the `XREAD` command.\n\n### The `XREAD` Command\n\nThe [`XREAD`](https://redis.io/docs/latest/commands/xread/) command is used to read data from one or more streams, starting from a specified entry ID.\n\nUnlike `XRANGE`, which requires both a `start` and `end` ID, `XREAD` takes only a single ID. \n\nAnother difference is that `XREAD` is exclusive. This means that the command retrieves all entries with an ID greater than the specified ID.\n\nThe basic syntax for the command is:\n```bash\nXREAD STREAMS <key> <id>\n```\n\n`XREAD` supports other optional arguments, but we won't deal with them at this stage.\n\nHere's an example of its behavior:\n\n```bash\n$ redis-cli XADD some_key 1526985054069-0 temperature 36 humidity 95\n\"1526985054069-0\"\n\n$ redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n\n$ redis-cli XREAD STREAMS some_key 1526985054069-0\n1) 1) \"some_key\"\n   2) 1) 1) 1526985054079-0\n         2) 1) temperature\n            2) 37\n            3) humidity\n            4) 94\n```\n\nThe return value is an array of streams, where each stream contains:\n\n- The stream key (as a bulk string).\n- An array of entries, where each entry is an array of two parts:\n  - The entry's ID (as a bulk string).\n  - An array of key-value pairs (as bulk strings).\n\nHere's what the response from the example above would look like:\n\n```json\n[\n  [\n    \"some_key\",\n    [\n      [\n        \"1526985054079-0\",\n        [\n          \"temperature\",\n          \"37\",\n          \"humidity\",\n          \"94\"\n        ]\n      ]\n    ]\n  ]\n]\n```\n\nWhen encoded as a RESP array, it looks like this:\n\n```text\n*1\\r\\n\n*2\\r\\n\n$8\\r\\nsome_key\\r\\n\n*1\\r\\n\n*2\\r\\n\n$15\\r\\n1526985054079-0\\r\\n\n*4\\r\\n\n$11\\r\\ntemperature\\r\\n\n$2\\r\\n37\\r\\n\n$8\\r\\nhumidity\\r\\n\n$2\\r\\n94\\r\\n\n```\n(*The result is shown on separate lines for readability. The actual return value is a single line.*)\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send an `XADD` command to add an entry to a stream.\n\n```bash\n$ redis-cli XADD stream_key 0-1 temperature 96\n```\n\nNext, the tester will send an `XREAD` command to your server.\n\n```bash\n$ redis-cli XREAD STREAMS stream_key 0-0\n```\n\nYour server should respond with a RESP array containing the correct stream entries.\n\nFrom the example above, your response should look like the following, encoded as a RESP array:\n\n```json\n[\n  [\n    \"stream_key\",\n    [\n      [\n        \"0-1\",\n        [\n          \"temperature\",\n          \"96\"\n        ]\n      ]\n    ]\n  ]\n]\n```\n"
    },
    {
      "slug": "ru9",
      "primary_extension_slug": "streams",
      "name": "Query multiple streams using XREAD",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add extend support to `XREAD` to allow querying multiple streams.\n",
      "description_md": "In this stage, you'll add support for querying multiple streams using the `XREAD` command.\n\n### The `XREAD` Command for Multiple Streams\n\nWhen reading from multiple streams, the `XREAD` command takes the `STREAMS` keyword, followed by a list of stream keys, and then a corresponding list of entry IDs for each stream.\n\nThe command format is: \n\n```bash\nXREAD STREAMS <key1> <key2> ... <id1> <id2> ...\n```\n\nThe server's response remains a RESP array of streams where:\n\n- Each stream is a two-item array: the stream's key and the entries read from it.\n- The order of the streams in the response must match the order in which they were specified in the command.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send multiple `XADD` commands to add entries to several streams.\n\n```bash\n$ redis-cli XADD stream_key 0-1 temperature 95\n$ redis-cli XADD other_stream_key 0-2 humidity 97\n```\n\nNext, the tester will send an `XREAD` command to your server with multiple streams.\n\n```bash\n$ redis-cli XREAD streams stream_key other_stream_key 0-0 0-1\n```\n\nYour server should respond with a RESP array containing the results for all the specified streams.\n\nFrom the example above, your response should look like the following, encoded as a RESP array:\n\n```json\n[\n  [\n    \"stream_key\",\n    [\n      [\n        \"0-1\",\n        [\n          \"temperature\",\n          \"95\"\n        ]\n      ]\n    ]\n  ],\n  [\n    \"other_stream_key\",\n    [\n      [\n        \"0-2\",\n        [\n          \"humidity\",\n          \"97\"\n        ]\n      ]\n    ]\n  ]\n]\n```\n"
    },
    {
      "slug": "bs1",
      "primary_extension_slug": "streams",
      "name": "Blocking reads",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll add extend support to `XREAD` to allow querying multiple streams.\n",
      "description_md": " In this stage, you’ll extend your `XREAD` implementation to support blocking.\n\n### Understanding Blocking in `XREAD`\n\nBy default, the `XREAD` command is synchronous: it returns data immediately if entries are available, or an empty response if not. \n\nHowever, with the optional `BLOCK` parameter, clients can wait for new data to arrive.\n\nThe syntax looks like this:\n\n```bash\nXREAD BLOCK <milliseconds> STREAMS <key> <id>\n```\n\nHere's how it works:\n- The client sends the command and specifies a timeout in milliseconds.\n- If the list of entries is empty, the command blocks and waits.\n- If a new entry is added to the stream before the timeout expires, the command unblocks and returns the new entry (or entries).\n- If the timeout expires and no new data has arrived, the server responds with a null array (`*-1\\r\\n`).\n\nFor example, consider two separate clients. The first client sends a blocking `XREAD` command:\n\n```bash\n$ redis-cli XREAD BLOCK 1000 streams some_key 1526985054069-0\n```\n\nThis client will now block and wait for a new entry to be added.\n\nMeanwhile, a second client can add an entry to the stream:\n\n```bash\n$ other-redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n```\n\nIf the entry is added within `1000` milliseconds, the first client's `XREAD` command will immediately unblock and respond with the new entry:\n\n```bash\n1) 1) \"some_key\"\n   2) 1) 1) 1526985054079-0\n      2) 1) temperature\n         2) 37\n         3) humidity\n         4) 94\n```\n\nHowever, if no new entry is added before the timeout expires, the command will fail and return a null array:\n\n```bash\n(nil)\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then add an entry to a stream.\n\n```bash\n$ redis-cli XADD stream_key 0-1 temperature 96\n```\n\nNext, it will send an `XREAD` command to your server with the `BLOCK` option.\n\n```bash\n$ redis-cli XREAD BLOCK 1000 streams stream_key 0-1\n```\n\nIn another instance of the redis-cli, the tester will add an entry within `500` milliseconds.\n\n```bash\n$ redis-cli XADD stream_key 0-2 temperature 95\n```\n\nYour server should respond to the first client with the following, encoded as a RESP array:\n\n```json\n[\n  [\n    \"stream_key\",\n    [\n      [\n        \"0-2\",\n        [\n          \"temperature\",\n          \"95\"\n        ]\n      ]\n    ]\n  ]\n]\n```\n\nNext, the tester will send another blocking `XREAD` command, but this time, it will allow the full timeout duration to elapse before checking the response.\n\n```bash\n$ redis-cli XREAD block 1000 streams stream_key 0-2\n```\n\nIn this case, your server should respond with a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) (`*-1\\r\\n`).\n"
    },
    {
      "slug": "hw1",
      "primary_extension_slug": "streams",
      "name": "Blocking reads without timeout",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add extend support to `XREAD` to allow for the blocking command not timing out.\n",
      "description_md": "In this stage, you'll extend your `XREAD` implementation to support blocking indefinitely.\n\n### Indefinite Blocking in `XREAD`\n\nAs a recap, the `XREAD` command supports blocking using the `BLOCK <milliseconds>` parameter. \n\nIf the `milliseconds` value is set to `0`, the `XREAD` command will block indefinitely until a new entry is added to the stream(s).\n\nFor example, consider two separate clients. The first client sends a blocking `XREAD` command with `0` as the time passed in:\n\n```bash\n$ redis-cli XREAD BLOCK 0 streams some_key 1526985054069-0\n```\n\nThis client will be blocked indefinitely until a new entry is added.\n\nIf the second client adds an entry to the stream at any time:\n\n```bash\n$ other-redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n```\n\nThe first client's `XREAD` command will immediately unblock and respond with the new entry:\n\n```bash\n1) 1) \"some_key\"\n   2) 1) 1) 1526985054079-0\n         2) 1) temperature\n            2) 37\n            3) humidity\n            4) 94\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then add an entry to a stream.\n\n```bash\n$ redis-cli XADD stream_key 0-1 temperature 96\n```\n\nNext, the tester will send an indefinite blocking `XREAD` command to your server:\n\n```bash\n$ redis-cli XREAD BLOCK 0 streams stream_key 0-1\n```\n\nIt will then pause for `1000` milliseconds to confirm the client remains blocked and doesn't time out. After that, it will add another entry:\n\n```bash\n$ redis-cli XADD stream_key 0-2 temperature 95\n```\n\nYour server should respond with the following, encoded as a RESP array:\n\n```json\n[\n  [\n    \"stream_key\",\n    [\n      [\n        \"0-2\",\n        [\n          \"temperature\",\n          \"95\"\n        ]\n      ]\n    ]\n  ]\n]\n```\n"
    },
    {
      "slug": "xu1",
      "primary_extension_slug": "streams",
      "name": "Blocking reads using $",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add extend support to `XREAD` to allow for passing in `$` as the ID for a blocking command.\n",
      "description_md": "In this stage, you’ll extend support for `XREAD` to handle `$` as the starting ID in a blocking read.\n\n### Understanding `$` as an Entry ID\n\nWhen `$` is passed as the ID, `XREAD` will only return new entries added after the command is sent. This is similar to passing in the maximum ID currently available in a stream.\n\nFor example, suppose we have two separate clients. The first client sends a blocking `XREAD` command with `1000` as the timeout and `$` as the ID:\n\n```bash\n$ redis-cli XREAD BLOCK 1000 streams some_key $\n```\n\nThen, the second client adds an entry to the `some_key` stream.\n\n```bash\n$ other-redis-cli XADD some_key 1526985054079-0 temperature 37 humidity 94\n\"1526985054079-0\"\n```\n\nSimilar to the behavior detailed in the earlier stages, if the command is sent within `1000` milliseconds, the first client will be unblocked and get the new entry:\n\n```bash\n1) 1) \"some_key\"\n   2) 1) 1) 1526985054079-0\n         2) 1) temperature\n            2) 37\n            3) humidity\n            4) 94\n```\n\nIf not, the response will be a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays).\n\n```bash\n(nil)\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then add an entry to a stream.\n\n```bash\n$ redis-cli XADD stream_key 0-1 temperature 96\n```\n\nNext, it will send an `XREAD` command to your server with the `BLOCK` command with `0` as the time and `$` as the ID.\n\n```bash\n$ redis-cli XREAD BLOCK 0 streams stream_key $\n```\n\nIn another instance of the redis-cli, the tester will add another entry after `500` milliseconds.\n\n```bash\n$ redis-cli XADD stream_key 0-2 temperature 95\n```\n\nYour server should respond with the following, as a RESP array:\n\n```json\n[\n  [\n    \"stream_key\",\n    [\n      [\n        \"0-2\",\n        [\n          \"temperature\",\n          \"95\"\n        ]\n      ]\n    ]\n  ]\n]\n```\n\nAfter that, the tester will send another `XREAD` command to your server with the `BLOCK` command, but this time, it'll wait for `1000` milliseconds before checking the response of your server.\n\n```bash\n$ redis-cli XREAD BLOCK 1000 streams stream_key $\n```\n\nYour server should respond with a null array (`*-1\\r\\n`).\n"
    },
    {
      "slug": "si4",
      "primary_extension_slug": "transactions",
      "name": "The INCR command (1/3)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll start implementing the INCR command.\n",
      "description_md": "In this stage, you'll add support for the `INCR` command.\n\n### The INCR command\n\nThe [INCR](https://redis.io/docs/latest/commands/incr/) command is used to increment the value of a key by 1.\n\nExample usage:\n\n```bash\n$ redis-cli SET foo 5\n\"OK\"\n$ redis-cli INCR foo\n(integer) 6\n$ redis-cli INCR foo\n(integer) 7\n```\n\nIf the key doesn't exist, the value will be set to 1.\n\nWe'll split the implementation of this command into three stages:\n\n- Key exists and has a numerical value (**This stage**)\n- Key doesn't exist (later stages)\n- Key exists but doesn't have a numerical value (later stages)\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client and run the following commands:\n\n```bash\n$ redis-cli\n> SET foo 41 (expecting \"+OK\" as the response)\n> INCR foo (expecting \":42\\r\\n\" as the response)\n```\n"
    },
    {
      "slug": "lz8",
      "primary_extension_slug": "transactions",
      "name": "The INCR command (2/3)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll continue implementing the INCR command.\n",
      "description_md": "In this stage, you'll add support for handling the `INCR` command when a key does not exist.\n\n### Recap\n\nThe implementation of [`INCR`](https://redis.io/docs/latest/commands/incr/) is split into three stages:\n\n- Key exists and has a numerical value (previous stages)\n- Key doesn't exist (**This stage**)\n- Key exists but doesn't have a numerical value (later stages)\n\nWhen a key doesn't exist, `INCR` sets the value to 1. Example:\n\n```bash\n$ redis-cli INCR missing_key\n(integer) 1\n$ redis-cli GET missing_key\n\"1\"\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client and run the following commands:\n\n```bash\n$ redis-cli\n> INCR foo (expecting \":1\\r\\n\" as the response)\n> INCR bar (expecting \":1\\r\\n\" as the response)\n```\n\n### Notes\n\n- Your implementation still needs to pass the tests in the previous stage.\n"
    },
    {
      "slug": "mk1",
      "primary_extension_slug": "transactions",
      "name": "The INCR command (3/3)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll finish implementing the INCR command.\n",
      "description_md": "In this stage, you'll add support for handling the `INCR` command when a key exists but doesn't have a numerical value.\n\n### Recap\n\nThe implementation of [`INCR`](https://redis.io/docs/latest/commands/incr/) is split into three stages:\n\n- Key exists and has a numerical value (previous stages)\n- Key doesn't exist (previous stages)\n- Key exists but doesn't have a numerical value (**This stage**)\n\nWhen a key exists but doesn't have a numerical value, `INCR` will return an error. Example:\n\n```bash\n$ redis-cli SET foo xyz\n\"OK\"\n$ redis-cli INCR foo\n(error) ERR value is not an integer or out of range\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client and run the following commands:\n\n```bash\n$ redis-cli\n> SET foo xyz (expecting \"+OK\\r\\n\" as the response)\n> INCR foo (expecting \"-ERR value is not an integer or out of range\\r\\n\" as the response)\n```\n"
    },
    {
      "slug": "pn0",
      "primary_extension_slug": "transactions",
      "name": "The MULTI command",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll implement the MULTI command.\n",
      "description_md": "In this stage, you'll add support for the `MULTI` command.\n\n### The MULTI command\n\nThe [MULTI](https://redis.io/docs/latest/commands/multi/) command starts a transaction.\n\nAfter a `MULTI` command is executed, any further commands from the same connection will be \"queued\" but not executed.\n\nExample usage:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo 41\nQUEUED\n> INCR foo\nQUEUED\n```\n\nThe queued commands can be executed using [EXEC](https://redis.io/docs/latest/commands/exec/), which we'll cover in later stages.\n\nIn this stage, you'll just add support for handling the `MULTI` command and returning `+OK\\r\\n`. We'll get to queueing commands in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client and run the following command:\n\n```bash\n$ redis-cli MULTI\n```\n\nThe tester will expect `+OK\\r\\n` as the response.\n\n### Notes\n\n- We'll test queueing commands & executing a transaction in later stages.\n"
    },
    {
      "slug": "lo4",
      "primary_extension_slug": "transactions",
      "name": "The EXEC command",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll start implementing the EXEC command.\n",
      "description_md": "In this stage, you'll add support for the `EXEC` command when the `MULTI` command has not been called.\n\n### The EXEC command\n\nThe [EXEC](https://redis.io/docs/latest/commands/exec/) command executes all commands queued in a transaction.\n\nIt returns an array of the responses of the queued commands.\n\nExample usage:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo 41\nQUEUED\n> INCR foo\nQUEUED\n> EXEC\n1) OK\n2) (integer) 42\n```\n\n### EXEC without MULTI\n\nIf `EXEC` is executed without having called `MULTI`, it returns an error.\n\nExample usage:\n\n```bash\n$ redis-cli EXEC\n(error) ERR EXEC without MULTI\n```\n\nThe returned value is a [Simple error](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-errors), the\nexact bytes are `-ERR EXEC without MULTI\\r\\n`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client and run the following commands:\n\n```bash\n$ redis-cli EXEC\n```\n\nThe tester will expect \"-ERR EXEC without MULTI\\r\\n\" as the response.\n\n### Notes\n\n- In this stage you only need to implement `EXEC` when `MULTI` hasn't been called.\n- We'll test handling `EXEC` after `MULTI` in later stages.\n"
    },
    {
      "slug": "we1",
      "primary_extension_slug": "transactions",
      "name": "Empty transaction",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll implement an empty transaction.\n",
      "description_md": "In this stage, you'll add support for executing an empty transaction.\n\n### Empty transactions\n\nIf [EXEC](https://redis.io/docs/latest/commands/exec/) is executed soon after [MULTI](https://redis.io/docs/latest/commands/multi/),\nit returns an empty array.\n\nThe empty array signifies that no commands were queued, and that the transaction was executed successfully.\n\nExample usage:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> EXEC\n(empty array)\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client and run the following commands:\n\n```bash\n$ redis-cli\n> MULTI (expecting \"+OK\\r\\n\")\n> EXEC (expecting \"*0\\r\\n\" as the response)\n> EXEC (expecting \"-ERR EXEC without MULTI\\r\\n\" as the response)\n```\n"
    },
    {
      "slug": "rs9",
      "primary_extension_slug": "transactions",
      "name": "Queueing commands",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll implement queueing commands to a transaction.\n",
      "description_md": "In this stage, you'll add support for queuing commands within a transaction.\n\n### Queuing commands\n\nAfter [MULTI](https://redis.io/docs/latest/commands/multi/) is executed, any further commands\nfrom a connection are queued until [EXEC](https://redis.io/docs/latest/commands/exec/) is executed.\n\nThe response to all of these commands is `+QUEUED\\r\\n` (That's `QUEUED` encoded as a [Simple String](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-strings)).\n\nExample:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo 41\nQUEUED\n> INCR foo\nQUEUED\n\n... (and so on, until EXEC is executed)\n```\n\nWhen commands are queued, they should not be executed or alter the database in any way.\n\nIn the example above, until `EXEC` is executed, the key `foo` will not exist.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client, and send multiple commands using the same connection:\n\n```bash\n$ redis-cli\n> MULTI\n> SET foo 41 (expecting \"+QUEUED\\r\\n\")\n> INCR foo (expecting \"+QUEUED\\r\\n\")\n```\n\nSince these commands were only \"queued\", the key `foo` should not exist yet. The tester will verify this by creating\nanother connection and sending this command:\n\n```bash\n$ redis-cli GET foo (expecting `$-1\\r\\n` as the response)\n```\n"
    },
    {
      "slug": "fy6",
      "primary_extension_slug": "transactions",
      "name": "Executing a transaction",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll implement executing a successful transaction.\n",
      "description_md": "In this stage, you'll add support for executing a transaction that contains multiple commands.\n\n### Executing a transaction\n\nWhen the [EXEC](https://redis.io/docs/latest/commands/exec/) command is sent within a transaction,\nall commands queued in that transaction are executed.\n\nThe response to [EXEC](https://redis.io/docs/latest/commands/exec/) is an array of the responses of the queued commands.\n\nExample:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo 41\nQUEUED\n> INCR foo\nQUEUED\n> EXEC\n1) OK\n2) (integer) 42\n```\n\nIn the above example, `OK` is the response of the `SET` command, and `42` is the response of the `INCR` command.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client, and send multiple commands using the same connection:\n\n```bash\n$ redis-cli MULTI\n> SET foo 6 (expecting \"+QUEUED\\r\\n\")\n> INCR foo (expecting \"+QUEUED\\r\\n\")\n> INCR bar (expecting \"+QUEUED\\r\\n\")\n> GET bar (expecting \"+QUEUED\\r\\n\")\n> EXEC (expecting an array of responses for the queued commands)\n```\n\nSince the transaction was executed, the key `foo` should exist and have the value `7`.\n\nThe tester will verify this by running a GET command:\n\n```bash\n$ redis-cli GET foo (expecting \"7\" encoded as a bulk string)\n```\n"
    },
    {
      "slug": "rl9",
      "primary_extension_slug": "transactions",
      "name": "The DISCARD command",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll implement the DISCARD command.\n",
      "description_md": "In this stage, you'll add support for the DISCARD command.\n\n### The DISCARD command\n\n[DISCARD](https://redis.io/docs/latest/commands/discard/) is used to abort a transactions. It discards all commands queued in a transaction,\nand returns `+OK\\r\\n`.\n\nExample:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo 41\nQUEUED\n> DISCARD\nOK\n> DISCARD\n(error) ERR DISCARD without MULTI\n```\n\nIn the above example, note that the first `DISCARD` returns `OK`, but the second `DISCARD` returns an error since the transaction was aborted.\n\n### DISCARD\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client, and send multiple commands using the same connection:\n\n```bash\n$ redis-cli\n> MULTI\n> SET foo 41 (expecting \"+QUEUED\\r\\n\")\n> INCR foo (expecting \"+QUEUED\\r\\n\")\n> DISCARD (expecting \"+OK\\r\\n\")\n> GET foo (expecting \"$-1\\r\\n\" as the response)\n> DISCARD (expecting \"-ERR DISCARD without MULTI\\r\\n\" as the response)\n```\n"
    },
    {
      "slug": "sg9",
      "primary_extension_slug": "transactions",
      "name": "Failures within transactions",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll implement handling failures while executing a transaction.\n",
      "description_md": "In this stage, you'll add support for handling failures within a transaction.\n\n### Failures within transactions\n\nWhen executing a transaction, if a command fails, the error is captured and returned within the response for `EXEC`. All other commands in\nthe transaction are still executed.\n\nYou can read more about this behaviour [in the official Redis docs](https://redis.io/docs/latest/develop/interact/transactions/#errors-inside-a-transaction).\n\nExample:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo xyz\nQUEUED\n> INCR foo\nQUEUED\n> SET bar 7\n> EXEC\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) OK\n```\n\nIn the example above, note that the error for the `INCR` command was returned as the second array element. The third command (`SET bar 7`) was\nstill executed successfully.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as a Redis client, and send multiple commands using the same connection:\n\n```bash\n$ redis-cli\n> SET foo abc\nOK\n> SET bar 41\nOK\n> MULTI\nOK\n> INCR foo\nQUEUED\n> INCR bar\nQUEUED\n> EXEC\n1) (error) ERR value is not an integer or out of range\n2) (integer) 42\n```\n\nThe expected response for `EXEC` is a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays) of\nthe responses of the queued commands. The exact bytes will be:\n\n```bash\n*2\\r\\n-ERR value is not an integer or out of range\\r\\n:42\\r\\n\n```\n\nThe tester will also verify that the last command was successfully executed and that the key `bar` exists:\n\n```bash\n$ redis-cli\n> GET foo (expecting \"$3\\r\\nabc\\r\\n\" as the response)\n> GET bar (expecting \"$2\\r\\n42\\r\\n\" as the response)\n```\n\n### Notes\n\n- There are a subset of command failures (like syntax errors) that will cause a transaction to be aborted entirely. We won't\n  cover those in this challenge.\n"
    },
    {
      "slug": "jf8",
      "primary_extension_slug": "transactions",
      "name": "Multiple transactions",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll implement multiple concurrent transactions.\n",
      "description_md": "In this stage, you'll add support for multiple concurrent transactions.\n\n### Multiple transactions\n\nThere can be multiple transactions open (i.e. `MULTI` has been called, but `EXEC` has not been called yet) at the same time. Each\ntransaction gets its own command queue.\n\nFor example, say you started transaction 1 from one connection:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> SET foo 41\nQUEUED\n> INCR foo\nQUEUED\n```\n\nand started transaction 2 from another connection:\n\n```bash\n$ redis-cli\n> MULTI\nOK\n> INCR foo\nQUEUED\n```\n\nIf you then run `EXEC` in transaction 1, you should see the following:\n\n```bash\n> EXEC\n1) OK\n2) (integer) 42\n```\n\n`OK` is the response to `SET foo 41`, and `42` is the response to `INCR foo`.\n\nAnd for transaction 2, running `EXEC` should return:\n\n```bash\n> EXEC\n1) (integer) 43\n```\n\n43 is the response to `INCR foo`. The key `foo` was updated to `42` by transaction 1, and `INCR foo` further increments it to `43`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nThe tester will then connect to your server as multiple Redis clients, and send multiple commands from each connection:\n\n```bash\n$ redis-cli MULTI\n> INCR foo\n> EXEC\n```\n"
    },
    {
      "slug": "mh6",
      "primary_extension_slug": "lists",
      "name": "Create a list",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for creating a new list using the `RPUSH` command.",
      "description_md": "In this stage, you'll add support for creating a new list using the `RPUSH` command.\n\n### The `RPUSH` Command\n\nThe [`RPUSH`](https://redis.io/docs/latest/commands/rpush/) command is used to append elements to a list. If the list doesn't exist, it is created first.\n\nExample usage:\n\n```bash\n# Creating a new list with a single element\n> RPUSH list_key \"foo\"\n(integer) 1\n\n# Appending a single element to an existing list\n> RPUSH list_key \"bar\"\n(integer) 2\n```\n\nThe return value is the number of elements in the list after appending. This value is encoded as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send the following command to your program:\n\n```bash\n$ redis-cli RPUSH list_key \"element\"\n```\n\nThe tester will verify that the response to the command is `:1\\r\\n`, which is 1 (the number of elements in the list), encoded as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\n### Notes\n\n- In this stage, you'll only need to handle creating a new list with a single element. We'll get to handling `RPUSH` for existing lists and multiple elements in later stages. \n"
    },
    {
      "slug": "tn7",
      "primary_extension_slug": "lists",
      "name": "Append an element",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for `RPUSH` when a list already exists and a single element is being appended.",
      "description_md": "In this stage, you’ll add support for `RPUSH` to append a single element to an existing list.\n\n### Appending to an Existing List\n\nWhen a client sends [`RPUSH`](https://redis.io/docs/latest/commands/rpush/) on a list that already exists, the new element is appended to the end of the list. \n```bash\n$ redis-cli RPUSH list_key \"element1\"\n(integer) 1\n$ redis-cli RPUSH list_key \"element2\"\n(integer) 2\n```\nThe server then returns the new length of the list as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send multiple `RPUSH` commands on the same list:\n\n```bash\n$ redis-cli RPUSH list_key \"element1\"\n# Expect: (integer) 1 → encoded as :1\\r\\n\n\n$ redis-cli RPUSH list_key \"element2\"\n# Expect: (integer) 2 → encoded as :2\\r\\n\n```\n\nIn each case, the tester will expect the response to be the length of the list encoded as a RESP integer. \n\n### Notes\n- You'll need to check if a list already exists for the given key and append to it.\n"
    },
    {
      "slug": "lx4",
      "primary_extension_slug": "lists",
      "name": "Append multiple elements",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for appending multiple elements in a single `RPUSH` command.",
      "description_md": "In this stage, you'll add support for appending multiple elements in a single `RPUSH` command.\n\n### `RPUSH` with multiple elements\n\nThe `RPUSH` command supports adding multiple elements to a list at once.\n\n```bash\n# Creating a new list with multiple elements\n> RPUSH another_list \"bar\" \"baz\"\n(integer) 2\n\n# Appending multiple elements to an existing list\n> RPUSH another_list \"foo\" \"bar\" \"baz\"\n(integer) 5\n```\n\nThe response to each command is the new length of the list returned as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send multiple `RPUSH` commands, each including more than one element to append to the list.\n\n```bash\n$ redis-cli RPUSH list_key \"element1\" \"element2\" \"element3\"\n# Expect: (integer) 3 → encoded as :3\\r\\n\n\n$ redis-cli RPUSH list_key \"element4\" \"element5\"\n# Expect: (integer) 5 → encoded as :5\\r\\n\n```\n\nIn each case, the tester will expect the response to be the length of the list encoded as a RESP integer.\n\n### Notes\n\n- `RPUSH` accepts multiple elements even when creating a new list, not only when appending to an existing list. \n"
    },
    {
      "slug": "sf6",
      "primary_extension_slug": "lists",
      "name": "List elements (positive indexes)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you will add support for listing the elements of a list using the `LRANGE` command.",
      "description_md": "In this stage, you will add support for listing the elements of a list using the `LRANGE` command.\n\n### The `LRANGE` command\n\nThe `LRANGE` command is used to retrieve elements from a list using a `start` index and a `stop` index.\n\nThe index of the first element is `0`. The `stop` index is inclusive, meaning the element at that index is included in the response.\n\nFor example:\n\n```bash\n# Create a list with 5 items\n> RPUSH list_key \"a\" \"b\" \"c\" \"d\" \"e\"\n(integer) 5\n\n# List first 2 items \n> LRANGE list_key 0 1\n1) \"a\"\n2) \"b\"\n\n# List items from index 2 to 4\n> LRANGE list_key 2 4\n1) \"c\"\n2) \"d\"\n3) \"e\"\n```\n\nThe `LRANGE` command has several behaviors to keep in mind:\n\n- If the list doesn't exist, an empty array is returned.\n- If the `start` index is greater than or equal to the list's length, an empty array is returned.\n- If the `stop` index is greater than or equal to the list's length, the `stop` index is treated as the last element.\n- If the `start` index is greater than the `stop` index, an empty array is returned.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then create a new list with multiple elements:\n\n```bash\n$ redis-cli RPUSH list_key \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n\nAfter that, the tester will send your program a series of `LRANGE` commands. For each command, it will expect the response to be a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays) or an empty array (`*0\\r\\n`), depending on the test case.\n\nAs an example, the tester might send your program a command like this:\n\n```bash\n$ redis-cli LRANGE list_key 0 2\n# Expect RESP Encoded Array: [\"a\", \"b\", \"c\"]\n```\n\nIt will expect the response to be a RESP array `[\"a\", \"b\", \"c\"]`, which would look like this:\n\n```bash\n*3\\r\\n\n$1\\r\\n\na\\r\\n\n$1\\r\\n\nb\\r\\n\n$1\\r\\n\nc\\r\\n\n```\n\n### Notes\n\n- In this stage, you will only implement `LRANGE` with non-negative indexes. We will get to handling `LRANGE` for negative indexes in the next stage.\n- If a list doesn't exist, `LRANGE` should respond with an empty RESP array (`*0\\r\\n`). \n"
    },
    {
      "slug": "ri1",
      "primary_extension_slug": "lists",
      "name": "List elements (negative indexes)",
      "difficulty": "easy",
      "marketing_md": "In this stage, you will add support for negative indexes for the `LRANGE` command.",
      "description_md": "In this stage, you will add support for negative indexes for the `LRANGE` command.\n\n### `LRANGE` with negative indexes\n\nThe `LRANGE` command can also use negative indexes.\n\nA negative index is an offset from the end of the list: `-1` refers to the last element, `-2` refers to the second-to-last, and so on.\n\nFor example:\n\n```bash\n# Create a list with 5 items\n> RPUSH list_key \"a\" \"b\" \"c\" \"d\" \"e\"\n(integer) 5\n\n# List the last 2 items \n> LRANGE list_key -2 -1\n1) \"d\"\n2) \"e\"\n\n# List all items except the last 2\n> LRANGE list_key 0 -3\n1) \"a\"\n2) \"b\"\n3) \"c\"\n```\n\nIf a negative index is out of range (e.g., `-6` on a list of length `5`), it should be treated as `0` (the start of the list).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then create a new list with multiple elements.\n\n```bash\n$ redis-cli RPUSH list_key \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n\nThe tester will then send your program a series of `LRANGE` commands with one or more negative indexes.\n\nFor example, the tester might send you this command:\n\n```bash\n$ redis-cli LRANGE list_key 2 -1\n```\n\nIn this case, the tester expects the response to be the array `[\"c\", \"d\", \"e\"]`, which is RESP encoded as:\n\n```\n*3\\r\\n\n$1\\r\\n\nc\\r\\n\n$1\\r\\n\nd\\r\\n\n$1\\r\\n\ne\\r\\n\n``` \n"
    },
    {
      "slug": "gu5",
      "primary_extension_slug": "lists",
      "name": "Prepend elements",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for the `LPUSH` command, which prepends elements to a list.",
      "description_md": "In this stage, you'll add support for the `LPUSH` command, which prepends elements to a list.\n\n### The `LPUSH` Command\n\nThe `LPUSH` command is similar to `RPUSH`, except that it inserts elements at the start of the list instead of the end. If the list doesn't exist, it gets created first before prepending the elements.\n\nFor example:\n\n```bash\n> LPUSH list_key \"a\" \"b\" \"c\"\n(integer) 3\n```\n\nEven though the elements were listed as \"a\", \"b\", \"c\", they are added to the list in reverse order, so the list becomes `[\"c\", \"b\", \"a\"]`.\n\n```bash\n> LRANGE list_key 0 -1\n1) \"c\"\n2) \"b\"\n3) \"a\"\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send a series of `LPUSH` commands. For each command, the tester will expect the response to be the list's length as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\n```bash\n$ redis-cli\n> LPUSH list_key \"c\"\n# Expect: (integer) 1\n\n> LPUSH list_key \"b\" \"a\"\n# Expect: (integer) 3\n```\n\nIt'll also use the `LRANGE` command to verify that elements are inserted in the correct order.\n\n```bash\n> LRANGE list_key 0 -1\n# Expect RESP Encoded Array: [\"a\", \"b\", \"c\"]\n``` \n"
    },
    {
      "slug": "fv6",
      "primary_extension_slug": "lists",
      "name": "Query list length",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for querying the length of a list using `LLEN`.",
      "description_md": "In this stage, you'll add support for querying the length of a list using the `LLEN` command.\n\n### The `LLEN` Command\n\nThe [`LLEN`](https://redis.io/docs/latest/commands/llen/) command is used to get the length of a list. The result is encoded as a [RESP integer](https://redis.io/docs/latest/develop/reference/protocol-spec/#integers).\n\nFor example:\n\n```bash\n# Create a new list with 4 items\n> RPUSH list_key \"a\" \"b\" \"c\" \"d\"\n(integer) 4\n\n# Get the length of the new list\n> LLEN list_key\n(integer) 4\n```\n\nIf the list doesn't exist, the server returns `0` as a RESP integer.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then create a list with a random number of elements using `RPUSH`.\n\n```bash\n$ redis-cli\n> RPUSH list_key <random number of elements>\n```\n\nNext, it will send an `LLEN` command for the newly created list. \n\n```bash\n> LLEN list_key\n# Expect: list_length (RESP Encoded Integer)\n```\n\nThe tester will expect the response to be the length of the list encoded as a RESP integer.\n\nThe tester will also verify the response for a non-existent list:\n\n```bash\n> LLEN missing_list_key\n# Expect:  (integer) 0\n```\n\nIn this case, your program should respond with `0`, which is encoded as `:0\\r\\n`.\n"
    },
    {
      "slug": "ef1",
      "primary_extension_slug": "lists",
      "name": "Remove an element",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll implement support for removing a single element from the left using the `LPOP` command.",
      "description_md": "In this stage, you'll add support for removing the first element of a list using the `LPOP` command.\n\n### The `LPOP` Command\n\nThe [`LPOP`](https://redis.io/docs/latest/commands/lpop/) command removes and returns the first element of a list.\n\nHere's an example:\n\n```bash\n> RPUSH list_key \"a\" \"b\" \"c\" \"d\"\n(integer) 4\n\n> LPOP list_key\n\"a\"\n```\n\nIf the list is empty or doesn't exist, it returns a [null bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-bulk-strings) (`$-1\\r\\n`).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then create a list with some elements.\n\n```bash\n$ redis-cli\n> RPUSH list_key \"one\" \"two\" \"three\" \"four\" \"five\"\n```\n\nNext, it will send an `LPOP` command to your server specifying the list that was just created:\n\n```bash\n> LPOP list_key\n# Expecting: (Bulk string) \"one\"\n```\n\nThe tester will expect the removed element to be returned as a [RESP bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings) (`$3\\r\\none\\r\\n`).\n\nThe tester will also verify that the remaining elements are present in the list using the `LRANGE` command.\n\n```bash\n> LRANGE list_key 0 -1\n# Expect a RESP Encoded Array: [\"two\", \"three\", \"four\", \"five\"]\n``` \n"
    },
    {
      "slug": "jp1",
      "primary_extension_slug": "lists",
      "name": "Remove multiple elements",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for removing multiple elements in a single `LPOP` command.",
      "description_md": "In this stage, you'll add support for removing multiple elements in a single `LPOP` command.\n\n### `LPOP` with multiple elements\n\nThe `LPOP` command accepts an optional argument that specifies how many elements to remove from a list. The command returns the removed elements in a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays).\n\nFor example:\n\n```bash\n> RPUSH list_key \"a\" \"b\" \"c\" \"d\"\n(integer) 4\n> LPOP list_key 2\n1) \"a\"\n2) \"b\"\n> LRANGE list_key 0 -1\n1) \"c\"\n2) \"d\"\n```\n\nIn this case, `LPOP` removes the first two elements, `a` and `b`, and the list is left with `c` and `d`. \n\nIf the number of elements to remove is greater than the list's length, the command should remove all elements in the list and return them as a RESP array.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will first create a list with multiple elements.\n\n```bash\n$ redis-cli\n> RPUSH list_key \"one\" \"two\" \"three\" \"four\" \"five\"\n# Expect: 5 (RESP Encoded Integer)\n```\n\nAfter that, it will send your program an `LPOP` command with the number of elements to remove.\n\n```bash\n> LPOP list_key 2\n# Expect RESP Encoded Array: [\"one\", \"two\"]\n```\n\nThe tester will verify that the response is a RESP array of the removed elements.\n\nIt will also use the `LRANGE` command to verify the remaining elements in the list.\n\n```bash\n> LRANGE list_key 0 -1\n# Expect RESP Encoded Array: [\"three\", \"four\", \"five\"]\n``` \n"
    },
    {
      "slug": "ec3",
      "primary_extension_slug": "lists",
      "name": "Blocking retrieval",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for the `BLPOP` command, which blocks until an element is available to be popped.",
      "description_md": "In this stage, you'll add support for the `BLPOP` command, which blocks until an element is available to be popped.\n\n### The `BLPOP` Command\n\n[`BLPOP`](https://redis.io/docs/latest/commands/blpop/) is a blocking variant of the `LPOP` command. It waits for an element to become available on a list before popping it.\n\nIf the list is empty, the command blocks until:\n\n- A new element is added to the list\n- Or a specified timeout is reached.\n  \nIf the timeout is `0`, the command blocks indefinitely.\n\nFor example, a client can block on a list with an indefinite timeout like this:\n\n```bash\n> BLPOP list_key 0\n```\n\nThis client will wait until an element is added to `list_key`. When an element like `\"foobar\"` is added, it is removed from the list, and the server responds with a [RESP array](https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays):\n\n```bash\n1) \"list_key\"\n2) \"foobar\"\n```\n\nThe RESP array contains two bulk strings:\n1. The list name\n2. The element that was popped\n\nThe `BLPOP` command has a few other behaviours to keep in mind:\n\n- If a timeout duration is supplied, it is the number of seconds the client will wait for an element. \n- If no elements were inserted during the timeout interval, the server returns a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) (`*-1\\r\\n`).\n- If multiple clients are blocked for the same list, the server responds to the client that has been waiting the longest.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send a `BLPOP` command with the timeout set to `0`:\n\n```bash\n$ redis-cli BLPOP list_key 0\n# (Blocks)\n```\n\nAfter a short while, another client will push an element to the same list:\n\n```bash\n# In another client:\n$ redis-cli RPUSH list_key \"foo\"\n# Expect: (integer) 1\n```\n\nThe tester expects the first client to immediately receive the response, which is the RESP-encoded array `[\"list_key\", \"foo\"]`.\n\n```bash\n# RESP encoding of [\"list_key\", \"foo\"]\n*2\\r\\n\n$8\\r\\n\nlist_key\\r\\n\n$3\\r\\n\nfoo\\r\\n\n```\n\nThe tester will also test `BLPOP` using multiple blocking clients. It will spawn several clients and have each one send a `BLPOP` command to the same list.\n\n```bash\n# Client 1 sends BLPOP first\n$ redis-cli BLPOP another_list_key 0\n\n# Client 2 sends BLPOP second\n$ redis-cli BLPOP another_list_key 0\n```\n\nThen, a separate client will use `RPUSH` to add an element to the list.\n\n```\n$ redis-cli RPUSH another_list_key \"foo\"\n```\n\nThe tester will expect your server to respond to the client that sent the `BLPOP` command first (`Client 1`).\n\n### Notes\n\n- In this stage, the timeout argument will always be `0`, meaning `BLPOP` should wait indefinitely. We'll handle non-zero timeouts in a later stage.\n"
    },
    {
      "slug": "xj7",
      "primary_extension_slug": "lists",
      "name": "Blocking retrieval with timeout",
      "difficulty": "medium",
      "marketing_md": "In this stage, you will add support for a non-zero timeout duration for the `BLPOP` command.",
      "description_md": "In this stage, you'll add support for a non-zero timeout for the `BLPOP` command.\n\n### The `BLPOP` Command with a Non-Zero Timeout\n\nThe `BLPOP` command can accept a timeout duration in seconds. \n\n```bash\n$ redis-cli BLPOP list_key 0.5\n# (Blocks for 0.5 seconds)\n```\n\nIf an element is not available on the list within this time, the server returns a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) (`*-1\\r\\n`). If an element is pushed to the list before the timeout, the command unblocks and returns the list key and the popped element as a RESP array, just as in the previous stage.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```\n./your_program.sh\n```\n\nIt will then send a `BLPOP` command with a non-zero timeout:\n\n```bash\n$ redis-cli BLPOP list_key 0.1\n# (Blocks for 0.1 seconds)\n```\n\nAfter the timeout expires, the tester will expect to receive a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) (`*-1\\r\\n`) as the response.\n\nThe tester will also test the case where an element is appended to the list before the timeout is reached. In this case, the response should be a RESP encoded array like `[\"list_key\", \"foo\"]` where `foo` is the added element. \n"
    },
    {
      "slug": "mx3",
      "primary_extension_slug": "pub-sub",
      "name": "Subscribe to a channel",
      "difficulty": "easy",
      "marketing_md": "In this stage, you’ll add support for the `SUBSCRIBE` command.",
      "description_md": "In this stage, you’ll add support for the  `SUBSCRIBE` command.\n\n### The `SUBSCRIBE` Command\n\n[The `SUBSCRIBE` command](https://redis.io/docs/latest/commands/subscribe/) registers the client as a subscriber to a channel.\n\nExample Usage:\n\n```bash\n$ redis-cli\n> SUBSCRIBE mychan\n1) \"subscribe\"\n2) \"mychan\"\n3) (integer) 1\nReading messages... (press Ctrl-C to quit or any key to type command)\n```\n\nThe response is a RESP Array which contains three elements:\n\n1. \"subscribe\" (as a RESP bulk string)\n1. The channel name (as a RESP bulk string) \n1. The number of channels this client has subscribed to so far (as a RESP integer)\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `SUBSCRIBE` command with a channel name.\n\n```\n$ redis-cli SUBSCRIBE foo\n```\n\nThe tester will then expect the response to be `[\"subscribe\", \"foo\", 1]`, which is encoded in RESP as:\n\n```\n*3\\r\\n\n$9\\r\\n\nsubscribe\\r\\n\n$3\\r\\n\nfoo\\r\\n\n:1\\r\\n\n```\n\n### Notes\n\n- In this stage, you'll only need to handle a `SUBSCRIBE` command being sent once and from a single client. We'll get to handling multiple `SUBSCRIBE` commands in later stages."
    },
    {
      "slug": "zc8",
      "primary_extension_slug": "pub-sub",
      "name": "Subscribe to multiple channels",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for subscribing to multiple channels using the `SUBSCRIBE` command.",
      "description_md": "In this stage, you'll add support for subscribing to multiple channels using the `SUBSCRIBE` command.\n\n### Multiple SUBSCRIBE commands\n\nA client can send `SUBSCRIBE` multiple times to subscribe to different channels. For example:\n\n```bash\n$ redis-cli\n> SUBSCRIBE channel_1\n1) \"subscribe\"\n2) \"channel_1\"\n3) (integer) 1\n\n(subscribed mode)> SUBSCRIBE channel_2\n1) \"subscribe\"\n2) \"channel_2\"\n3) (integer) 2\n```\n\nA client can also subscribe to the same channel multiple times, but the total subscribed channels count (returned as the 3rd item in the response array) won't change.\n\nFor example:\n\n```bash\n$ redis-cli\n> SUBSCRIBE channel_1\n1) \"subscribe\"\n2) \"channel_1\"\n3) (integer) 1\n\n# The count remains 1 since channel is same\n(subscribed mode)> SUBSCRIBE channel_1\n1) \"subscribe\"\n2) \"channel_1\"\n3) (integer) 1\n```\n\nThe subscribed channels count is per-client, i.e. how many channels the current client is subscribed to.\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then spawn a client and send multiple `SUBSCRIBE` commands specifying a new channel each time.\n\n```bash\n$ redis-cli\n> SUBSCRIBE foo\n# Expect [\"subscribe\", \"foo\", 1]\n\n> SUBSCRIBE bar\n# Expect [\"subscribe\", \"bar\", 2]\n\n> SUBSCRIBE bar\n# Expect [\"subscribe\", \"bar\", 2]\n```\n\nThe tester will repeat this with other clients and verify that the subscribed channel counts are maintained per-client.\n"
    },
    {
      "slug": "aw8",
      "primary_extension_slug": "pub-sub",
      "name": "Enter subscribed mode",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for marking a client as having entered Subscribed mode.",
      "description_md": "In this stage, you'll add support for marking a client as having entered Subscribed mode.\n\n### Subscribe Mode\n\nAfter a subscribe command is sent, a client enters \"Subscribed mode\". In this mode, only a subset of commands is allowed:\n\n- `SUBSCRIBE`\n- `UNSUBSCRIBE`\n- `PSUBSCRIBE`\n- `PUNSUBSCRIBE`\n- `PING`\n- `QUIT`\n\nThe server will reject any other commands with an error, example:\n\n```\n$ redis-cli\n> SUBSCRIBE channel\n1) \"subscribe\"\n2) \"channel\"\n3) (integer) 1\n\n(subscribed mode)> ECHO hey\n(error) ERR Can't execute 'echo': only (P|S)SUBSCRIBE / (P|S)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\n```\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `SUBSCRIBE` command to your server to enter Subscribed mode:\n\n```bash\n$ redis-cli\n> SUBSCRIBE foo\n# Expecting [\"subscribe\", \"foo\", 1]\n```\n\nThe tester will then send a series of commands, which might be allowed or un-allowed for subscribed mode.\n\nFor un-allowed commands (like `SET`, `GET`, and `ECHO`) the tester will verify that your server responds with the following error:\n\n```\n> SET key value\n- ERR Can't execute 'set': only (P|S)SUBSCRIBE / (P|S)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context \n```\n\nThe tester only verifies that error message starts with \"ERR Can't execute '<command_name>'\", so you're free to use a flexible error message and not stick to the exact format that Redis uses.\n\nFor the `SUBSCRIBE` command, the tester will verify that the response is its usual response.\n```bash\n> SUBSCRIBE bar\n# Expecting [\"subscribe\", \"bar\", 2] as RESP-encoded array\n```\n\n### Notes\n\n- For un-allowed commands, the tester is lenient in checking error messages so you don't have to stick to the exact format Redis uses. The exact format it checks for is `ERR Can't execute '<command>'` (case-insensitive). Examples of error message strings that will pass tests: \n    - `ERR Can't execute 'set' in subscribed mode`\n    - `ERR can't execute 'SET' when one or more subscriptions exist`\n\n- In subscribed mode, `PING` has a different response (it doesn't respond with `+PONG\\r\\n`). We'll get to this in later stages. "
    },
    {
      "slug": "lf1",
      "primary_extension_slug": "pub-sub",
      "name": "PING in subscribed mode",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for responding to `PING` when a client is in subscribed mode.",
      "description_md": "In this stage, you'll add support for responding to `PING` when a client is in subscribed mode.\n\n### `PING` in subscribed mode\n\nIf a ping command is issued from a client after it enters subscribed mode, Redis does not respond with the usual response (`+PONG\\r\\n`). Instead it responds with a RESP array of two elements:\n\n1. \"pong\" (encoded as a bulk string)\n2. \"\" (empty bulk string)\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `SUBSCRIBE` command to your server to enter Subscribed mode:\n\n```bash\n$ redis-cli\n> SUBSCRIBE foo\n# Expecting [\"subscribe\", \"foo\", 1]\n```\n\nThe tester will then send a `PING` command.\n```\n> PING \n```\n\nIt will expect the response to be an RESP-encoded array `[\"pong\", \"\"]`, which would look like this:\n```\n*2\\r\\n\n$4\\r\\n\npong\\r\\n\n$0\\r\\n\n\\r\\n\n```\n\nThe tester will also send a `PING` command using a separate client, which is not subscribed to any channels.\n```\n> PING\n```\nIt will expect the response to be `+PONG\\r\\n`, which is \"PONG\" encoded as a RESP simple string."
    },
    {
      "slug": "hf2",
      "primary_extension_slug": "pub-sub",
      "name": "Publish a message",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for the `PUBLISH` command.",
      "description_md": "In this stage, you'll add support for the `PUBLISH` command\\.\n\n### The `PUBLISH` Command\n\n[The PUBLISH command](https://redis.io/docs/latest/commands/publish/) delivers a message to all clients subscribed to a channel.\n\n```\n> PUBLISH channel_name message_contents\n(integer) 3\n```\n\nThe response to the command is the number of clients that are subscribed to the channel.\n\nIn this stage, you will only implement responding back to the `PUBLISH` command. You don't need to deliver the message to clients yet — we'll get to this in later stages.\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then spawn multiple clients that listen on multiple channels.\n\n```bash\n# Client 1 subscribes to channel \"foo\"\n$ redis-cli\n> SUBSCRIBE foo\n\n# Client 2 subscribes to channel \"bar\"\n$ redis-cli\n> SUBSCRIBE bar\n\n# Client 3 subscribes to channel \"bar\"\n$ redis-cli\n> SUBSCRIBE bar\n```\n\nThe tester will then publish messages to different channels using `PUBLISH` and check whether the response matches the number of clients subscribed to the channel.\n\n```\n$ redis-cli PUBLISH bar \"msg\"\n(integer) 2\n```\n\nIn the above example, the expected response is 2 (encoded as a RESP integer) since 2 clients are subscribed to channel bar.\n\nSimilarly for the `foo` channel\n\n```\n$ redis-cli PUBLISH foo \"msg\"\n(integer) 1\n```\n\nThe tester expects the response to be 1 (encoded as a RESP integer) since only 1 client is subscribed to it.\n"
    },
    {
      "slug": "dn4",
      "primary_extension_slug": "pub-sub",
      "name": "Deliver messages",
      "difficulty": "hard",
      "marketing_md": "In this stage, you will add support for delivering published messages to subscribed clients.",
      "description_md": "In this stage, you will add support for delivering published messages to subscribed clients.\n\n### Delivering messages\n\nWhen a client runs `PUBLISH` the command, the message is \"delivered\" to all clients currently subscribed to the channel.\n\nFor example, if a client was subscribed to `channel_1` and the message `hello` was sent, it would see something like this:\n\n```bash\n$ redis-cli\n> SUBSCRIBE channel_1\n1) \"subscribe\"\n2) \"channel_1\"\n3) (integer) 1\n\n# (client is now in subscribed mode)\n\n# When a message is published, it receives the following array: \n1) \"message\"\n2) \"channel_1\"\n3) \"hello\"\n```\n\nEach subscribed client receives an array with 3 elements:\n\n1. \"message\"(as a RESP bulk string)\n1. The channel name (as a RESP bulk string)\n1. The message contents (as a RESP bulk string)\n\nIn this case, each subscribed client will receive  `[\"message\", \"channel_1\", \"hello\"]`, encoded as:\n\n```\n*3\\r\\n\n$7\\r\\n\nmessage\\r\\n\n$9\\r\\n\nchannel_1\\r\\n\n$5\\r\\n\nhello\\r\\n\n```\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then spawn multiple clients that listen on multiple channels.\n\n```bash\n# Client 1 subscribes to foo\n$ redis-cli\n> SUBSCRIBE foo\n\n# Client 2 subscribes to foo\n$ redis-cli\n> SUBSCRIBE foo\n\n# Client 3 subscribes to bar\n$ redis-cli\n> SUBSCRIBE bar\n```\n\nThe tester will then spawn a separate client and send `PUBLISH` commands for random channels.\n\n```bash\n$ redis-cli\n> PUBLISH foo \"hello\"\n2\n> PUBLISH bar \"world\"\n1\n```\n\nIt'll verify the `PUBLISH` commands returns the number of clients subscribed to the channel.\n\nFor every client, it'll also assert that the client receives the message if it is subscribed. The tester will verify that each subscribed client receives an array like this: `[\"message\", \"foo\", \"hello\"]`. When RESP-encoded, this looks like:\n\n```\n*3\\r\\n\n$7\\r\\n\nmessage\\r\\n\n$3\\r\\n\nfoo\\r\\n\n$5\\r\\n\nhello\\r\\n\n```\n\nIf a client isn't subscribed to a channel, the tester will validate that it doesn't receive messages sent to that channel.\n"
    },
    {
      "slug": "ze9",
      "primary_extension_slug": "pub-sub",
      "name": "Unsubscribe",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for the `UNSUBSCRIBE command`, which is used to unsubscribe from a channel.",
      "description_md": "In this stage, you'll add support for the `UNSUBSCRIBE` command, which is used to unsubscribe from a channel.\n\n### The `UNSUBSCRIBE` Command\n\nThis command removes the client from one or more channels. Example usage:\n\n```bash\n$ redis-cli\n> SUBSCRIBE foo\n1) \"subscribe\"\n2) \"foo\"\n3) (integer) 1\n(subscribed mode)> SUBSCRIBE bar\n1) \"subscribe\"\n2) \"bar\"\n3) (integer) 2\n(subscribed mode)> UNSUBSCRIBE foo\n1) \"unsubscribe\"\n2) \"foo\"\n3) (integer) 1\n(subscribed mode)> UNSUBSCRIBE bar\n1) \"unsubscribe\"\n2) \"bar\"\n3) (integer) 0\n```\n\nWhen unsubscribed, the server replies with a RESP Array with 3 elements:\n\n1. \"unsubscribe\" (as a RESP bulk string)\n1. The channel name (as a RESP bulk string)\n1. Count of remaining channels the client has subscribed to (as a RESP integer)\n\nWhen unsubscribing from a channel that has not been subscribed yet, it returns the array with no change in the remaining channels count. For eg,\n\n```bash\n$ redis-cli\n> subscribe foo\n1) \"subscribe\"\n2) \"foo\"\n3) (integer) 1\n\n(subscribed mode)> unsubscribe bar\n1) \"unsubscribe\"\n2) \"bar\"\n3) (integer) 1\n```\n\n### Tests\n\nThe tester will  run your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then spawn multiple clients that listen on multiple channels:\n\n```bash\n# Client 1 subscribes to 'foo' and 'baz'\n$ redis-cli\n> SUBSCRIBE foo\n> SUBSCRIBE baz\n\n# Client 2 subscribes to 'foo' and 'bar'\n$ redis-cli\n> SUBSCRIBE foo\n> SUBSCRIBE bar\n```\n\nThe tester will then spawn a separate client that publishes messages to random channels.\n\n```bash\n$ redis-cli\n> PUBLISH foo \"before-unsubscribe\"\n```\n\nIt will verify that any clients subscribed to the channel receive the message, and that other clients don't.\n\nThe tester will then issue random `UNSUBSCRIBE` commands to the subscribed clients:\n\n```bash\n# In client 1, which was subscribed to 'foo' and 'baz'\n> UNSUBSCRIBE foo\n# Expects [\"unsubscribed\", \"foo\", 1] as an RESP array\n```\n\nFinally, the tester will again publish messages to random channels:.\n\n```bash\n> PUBLISH foo \"after-unsubscribe\"\n```\n\nIt will verify that any clients subscribed to the channel receive the message, and that other clients don't."
    },
    {
      "slug": "ct1",
      "primary_extension_slug": "sorted-sets",
      "name": "Create a sorted set",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for creating a [sorted set](https://redis.io/docs/latest/develop/data-types/sorted-sets/) using the `ZADD` command.\n",
      "description_md": "In this stage, you'll add support for creating a [sorted set](https://redis.io/docs/latest/develop/data-types/sorted-sets/) using the `ZADD` command.\n\n### Redis Sorted Sets\n\nSorted sets are one of the data types that Redis supports. A sorted set is a collection of unique elements, where each element is associated with a floating-point score. Unlike regular sets, sorted sets maintain elements in a defined order based on their scores.\n\nThis makes them useful for use cases like leaderboards, priority queues, or any scenario where you need fast access to items sorted by a numerical value.\n\nFor example, if you were using sorted sets to store user rankings in a game leaderboard, the contents of the sorted set might look like this:\n\n```yaml\nracer_scores:\n    - member: \"Ford\"\n      score: 6.1\n    - member: \"Royce\"\n      score: 8.2\n    - member: \"Sam-Bodden\"\n      score: 8.2\n    - member: \"Prickett\"\n      score: 14.5\n```\n\nSorted sets are ordered based on increasing scores.\n\n\n### The `ZADD` Command\n\nThe [ZADD](https://redis.io/docs/latest/commands/zadd/) command is used to add a member to a sorted set.\n\nIf the sorted set does not exist, it is created and the member is added to it.\n\nExample usage:\n\n```bash\n> ZADD racer_scores 8.0 \"Sam\"\n(integer) 1\n```\n\nThe `ZADD` command takes the key, a score, and the member name as arguments. It returns an integer representing the number of new members added to the sorted set.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `ZADD` command specifying a key, value and score.\n\n```bash\n$ redis-cli ZADD zset_key 10.0 zset_member\n```\n\nThe tester will verify that the response to the command is `:1\\r\\n`, which is 1 (the number of members added to the sorted set), encoded as a RESP Integer.\n\n### Notes\n- In this stage, you'll only need to handle creating a new sorted set with a single member. We will get to adding new members to existing sorted set in the later stages.\n- It is recommended to store the score as a 64 bit floating point number for highest precision as the official Redis implementation uses [`double`](https://github.com/redis/redis/blob/bec644aab198049eaa5583631c419b4574b137e1/tests/modules/zset.c#L34).\n\n- We suggest that you implement sorted sets using a data structure where the members are stored in a sorted fashion according to their scores. It'll come in handy in the later stages.\n    -  Redis implements sorted sets using a combination of [hash table and skip list](https://github.com/redis/redis/blob/674b829981c0b8ad15a670a32df503e0e4514e96/src/server.h#L1560)."
    },
    {
      "slug": "hf1",
      "primary_extension_slug": "sorted-sets",
      "name": "Add members",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for adding elements to an existing sorted set.\n",
      "description_md": "In this stage, you'll add support for adding elements to an existing sorted set.\n\n### Adding elements using `ZADD`\n\nThe `ZADD` command can be used to add a new member to an existing sorted set, or update the score of an existing member. It returns the count of new members added to the sorted set as an integer.\n\n\nExample usage:\n```bash\n> ZADD zset_key 0.0043 foo\n(integer) 1\n> ZADD zset_key 8.0 bar\n(integer) 1\n\n# No new members were added\n> ZADD zset_key 10.0 bar\n(integer) 0\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `ZADD` command to create a new sorted set.\n\n```bash\n$ redis-cli ZADD zset_key 20.0 zset_member1 (Expecting \":1\\r\\n\")\n```\n\nThe tester will then send the `ZADD` command a few times to add new members.\n\n```bash\n$ redis-cli\n> ZADD zset_key 30.1 zset_member2 (Expecting \":1\\r\\n\")\n> ZADD zset_key 40.2 zset_member3 (Expecting \":1\\r\\n\")\n> ZADD zset_key 50.3 zset_member4 (Expecting \":1\\r\\n\")\n```\n\nThe tester expects the response to be `:1\\r\\n` whenever a new member is added.\n\nIt will then update the score of an existing member.\n```bash\n> ZADD zset_key 100.0 zset_member1 (Expecting \":0\\r\\n\")\n```\n\nThe tester expects the response to be `:0\\r\\n` whenever an existing member is updated."
    },
    {
      "slug": "lg6",
      "primary_extension_slug": "sorted-sets",
      "name": "Retrieve member rank",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for retrieving the rank of a sorted set member using the `ZRANK` command.\n",
      "description_md": "In this stage, you'll add support for retrieving the rank of a sorted set member using the `ZRANK` command.\n\n### The `ZRANK` Command\n\nThe `ZRANK` command is used to query the rank of a member in a sorted set. It returns an integer, which is 0-based index of the member when the sorted set is ordered by increasing score.\nIf two members have same score, the members are ordered lexicographically.\n\nExample usage:\n```bash\n> ZADD zset_key 1.0 member_with_score_1\n(integer) 1\n> ZADD zset_key 2.0 member_with_score_2\n(integer) 1\n> ZADD zset_key 2.0 another_member_with_score_2\n(integer) 1\n\n\n> ZRANK zset_key member_with_score_1\n(integer) 0\n> ZRANK zset_key member_with_score_2\n(integer) 2\n> ZRANK zset_key another_member_with_score_2\n(integer) 1\n```\n\nThe rank of `another_member_with_score_2` is 1, and `member_with_score_2` is 2. It is because though the both members have same scores, `another_member_with_score_2` preceeds `member_with_score_2` lexicographically.\n\n\nIf the member, or the sorted set does not exist, the command returns null bulk string (`$-1\\r\\n`).\n```bash\n# Missing sorted set and member\n> ZRANK zset_key missing_member\n(nil)\n> ZRANK missing_key member\n(nil)\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `ZADD` command to create and add new members to it.\n\n```bash\n$ redis-cli\n> ZADD zset_key 100.0 foo (Expecting \":1\\r\\n\")\n> ZADD zset_key 100.0 bar (Expecting \":1\\r\\n\")\n> ZADD zset_key 20.0 baz (Expecting \":1\\r\\n\")\n> ZADD zset_key 30.1 caz (Expecting \":1\\r\\n\")\n> ZADD zset_key 40.2 paz (Expecting \":1\\r\\n\")\n\n# Expected Ranks\n# baz -> 0\n# caz -> 1\n# paz -> 2\n# bar -> 3\n# foo -> 4\n```\n\nThe tester will then send multiple `ZRANK` commands specifying the members of the sorted set.\n```bash\n> ZRANK zset_key caz (Expecting \":1\\r\\n\")\n> ZRANK zset_key baz (Expecting \":0\\r\\n\")\n> ZRANK zset_key foo (Expecting \":4\\r\\n\")\n> ZRANK zset_key bar (Expecting \":3\\r\\n\")\n```\n\nThe tester will also send `ZRANK` commands where either the member or key doesn't exist.\n\n```bash\n> ZRANK zset_key missing_member (Expecting RESP bulk string \"$-1\\r\\n\")\n> ZRANK missing_key member (Expecting RESP bulk string \"$-1\\r\\n\")\n```"
    },
    {
      "slug": "ic1",
      "primary_extension_slug": "sorted-sets",
      "name": "List sorted set members",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for listing the members of a sorted set using the `ZRANGE` command.\n",
      "description_md": "In this stage, you'll add support for listing the members of a sorted set using the `ZRANGE` command.\n\n### The `ZRANGE` command\nThe `ZRANGE` command is used to list the members in a sorted set given a start index and an end index. The index of the first element is 0. The end index is inclusive, which means that the element at the end index will be included in the response.\n\nExample usage:\n```bash\n> ZADD racer_scores 8.1 \"Sam-Bodden\"\n(integer) 1\n> ZADD racer_scores 10.2 \"Royce\"\n(integer) 1\n> ZADD racer_scores 6.0 \"Ford\"\n(integer) 1\n> ZADD racer_scores 14.1 \"Prickett\"\n(integer) 1\n\n# List members from index 0 to 2\n> ZRANGE racer_scores 0 2\n1) \"Ford\"\n2) \"Sam-Bodden\"\n3) \"Royce\"\n```\n\nHere are some additional notes on how the `ZRANGE` command behaves with different types of inputs:\n\n- If the sorted set does not exist, an empty array (`*0\\r\\n`) is returned\n- If the start index is greater than or equal to the cardinality of the sorted set, an empty array is returned.\n- If the stop index is greater than the cardinality of the sorted set, the stop index is treated as the last element.\n- If the start index is greater than the stop index, the result is an empty array.\n\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then create a new sorted set with multiple members.\n\n```bash\n$ redis-cli\n> ZADD zset_key 100.0 foo (Expecting \":1\\r\\n\")\n> ZADD zset_key 100.0 bar (Expecting \":1\\r\\n\")\n> ZADD zset_key 20.0 baz (Expecting \":1\\r\\n\")\n> ZADD zset_key 30.1 caz (Expecting \":1\\r\\n\")\n> ZADD zset_key 40.2 paz (Expecting \":1\\r\\n\")\n```\n\nAfter that the tester will send your program a series of `ZRANGE` commands. It will expect the response to be a RESP array, or an empty array in each case, depending on the test case.\n\nAs an example, the tester might send your program a command like this.\n```bash\n> ZRANGE zset_key 2 4\n# Expect RESP Encoded Array: [\"paz\", \"bar\", \"foo\"]\n```\n\nIt will expect the response to be an RESP-encoded array `[\"paz\", \"bar\", \"foo\"]`, which would look like this:\n```\n*3\\r\\n\n$3\\r\\n\npaz\\r\\n\n$3\\r\\n\nbar\\r\\n\n$3\\r\\n\nfoo\\r\\n\n```\n\nThe tester will issue multiple such commands and verify their responses.\n\n### Notes\n\n- In this stage, you will only implement `ZRANGE` with non-negative indexes. We will get to handling `ZRANGE` with negative indexes in the next stage."
    },
    {
      "slug": "bj4",
      "primary_extension_slug": "sorted-sets",
      "name": "ZRANGE with negative indexes",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for negative indexes for the `ZRANGE` command.\n",
      "description_md": "In this stage, you'll add support for negative indexes for the `ZRANGE` command.\n\n### `ZRANGE` with negative indexes\n\nThe `ZRANGE` command can accept negative indexes too.\n\nExample usage:\n\n```bash\n> ZADD racer_scores 8.5 \"Sam-Bodden\"\n(integer) 1\n> ZADD racer_scores 10.2 \"Royce\"\n(integer) 1\n> ZADD racer_scores 6.1 \"Ford\"\n(integer) 1\n> ZADD racer_scores 14.9 \"Prickett\"\n(integer) 1\n> ZADD racer_scores 10.2 \"Ben\"\n(integer) 1\n\n\n# List last 2 elements\n> ZRANGE racer_scores -2 -1\n1) \"Royce\"\n2) \"Prickett\"\n\n# List all items except last 2\n> ZRANGE racer_scores 0 -3\n1) \"Ford\"\n2) \"Sam-Bodden\"\n3) \"Ben\"\n```\n\nAn index of -1 refers to the last element, -2 to the second last, and so on. If a absolute value of the negative index is out of range (i.e. >= the cardinality of the sorted set), it is treated as 0 (start of the sorted set).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `ZADD` command to create a sorted set and add members to it.\n\n```bash\n$ redis-cli\n> ZADD zset_key 20.0 foo (Expecting \":1\\r\\n\")\n> ZADD zset_key 30.1 bar (Expecting \":1\\r\\n\")\n> ZADD zset_key 40.2 baz (Expecting \":1\\r\\n\")\n> ZADD zset_key 25.0 paz (Expecting \":1\\r\\n\")\n> ZADD zset_key 25.0 caz (Expecting \":1\\r\\n\")\n```\n\nThe tester will then send your program a series of `ZRANGE` commands with one or more negative indexes.\n\nFor example, the tester might send you this command:\n\n```bash\n> ZRANGE zset_key 2 -1\n1) \"paz\"\n2) \"bar\"\n3) \"baz\"\n```\n\nIn this case, the tester will verify that the response is the array `[\"paz\", \"bar\", \"baz\"]`, which is RESP Encoded as:\n\n```\n*3\\r\\n\n$3\\r\\n\npaz\\r\\n\n$3\\r\\n\nbar\\r\\n\n$3\\r\\n\nbaz\\r\\n\n```"
    },
    {
      "slug": "kn4",
      "primary_extension_slug": "sorted-sets",
      "name": "Count sorted set members",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for counting the number of members in a sorted set using the `ZCARD` command.\n",
      "description_md": "In this stage, you'll add support for counting the number of members in a sorted set using the `ZCARD` command.\n\n### The `ZCARD` Command\n\nThe `ZCARD` command is used to query the cardinality (number of elements) of a sorted set. It returns an integer. The response is 0 if the sorted set specified does not exist.\n\n```bash\n> ZADD zset_key 1.2 \"one\"\n(integer) 1\n> ZADD zset_key 2.2 \"two\"\n(integer) 1\n> ZCARD zset_key\n(integer) 2\n\n> ZCARD missing_key\n(integer) 0\n```\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `ZADD` command to create and add members to it.\n\n```bash\n$ redis-cli\n> ZADD zset_key 20.0 zset_member1 (Expecting \":1\\r\\n\")\n> ZADD zset_key 30.1 zset_member2 (Expecting \":1\\r\\n\")\n> ZADD zset_key 40.2 zset_member3 (Expecting \":1\\r\\n\")\n> ZADD zset_key 50.3 zset_member4 (Expecting \":1\\r\\n\")\n```\n\nIt will check the number of elements in the sorted set using the `ZCARD` command.\n```bash\n$ redis-cli ZCARD zset_key (Expecting \":4\\r\\n\")\n```\n\nThe tester will then update the score of an existing member.\n```bash\n$ redis-cli ZADD zset_key 100.0 zset_member1 (Expecting \":0\\r\\n\")\n```\n\nIt will again check the cardinality of the sorted set using the `ZCARD` command.\n```bash\n$ redis-cli ZCARD zset_key (Expecting \":4\\r\\n\")\n```\n\nThe tester will also check the cardinality of a non existing sorted set.\n```bash\n$ redis-cli ZCARD missing_key (Expecting \":0\\r\\n\")\n```"
    },
    {
      "slug": "gd7",
      "primary_extension_slug": "sorted-sets",
      "name": "Retrieve member score",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for retrieving the score of a sorted set member using the `ZSCORE` command.\n",
      "description_md": "In this stage, you'll add support for retrieving the score of a sorted set member using the `ZSCORE` command.\n\n### The `ZSCORE` Command\n\nThe `ZSCORE` command is used to query the score of a member of a sorted set. If the sorted set and the member both exist, the score of the member is returned as a RESP bulk string.\n```bash\n> ZADD zset_key 24.34 \"one\"\n(integer) 1\n> ZADD zset_key 90.34 \"two\"\n(integer) 1\n> ZSCORE zset_key \"one\"\n\"24.34\"\n```\n\nIf the member or the sorted set specified in the argument does not exist, RESP null bulk string(`$-1\\r\\n`) is returned.\n```bash\n> ZSCORE zset_key \"three\"\n(nil)\n> ZSCORE missing_key \"member\"\n(nil)\n```\n\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `ZADD` command to create a sorted set and add new members to it.\n\n```bash\n$ redis-cli\n> ZADD zset_key 20.0 zset_member1 (Expecting \":1\\r\\n\")\n> ZADD zset_key 30.1 zset_member2 (Expecting \":1\\r\\n\")\n> ZADD zset_key 40.2 zset_member3 (Expecting \":1\\r\\n\")\n> ZADD zset_key 50.3 zset_member4 (Expecting \":1\\r\\n\")\n```\n\nThe tester will then send a `ZSCORE` command specifying one of the members. For example, the tester may send your program a command like this:\n\n```bash\n> ZSCORE zset_key zset_member2 (Expecting RESP bulk string \"30.1\")\n```\n\nIt will expect the response to be \"30.1\", which is the score of `zset_member2`. The response is encoded as a RESP bulk string:\n```\n$4\\r\\n\n30.1\\r\\n\n```\n\nThe tester will then update the value of the member.\n```bash\n> ZADD zset_key 100.99 zset_member2 (Expecting \":0\\r\\n\")\n```\n\nThe tester will then send a `ZSCORE` command specifying the updated member.\n\n```bash\n> ZSCORE zset_key zset_member2 (Expecting RESP bulk string \"100.99\")\n```\n\nThe tester will also send `ZSCORE` commands where either the member or the key doesn't exist.\n```bash\n> ZSCORE zset_key zset_member100 (Expecting RESP bulk string \"$-1\\r\\n\")\n> ZSCORE missing_key member (Expecting RESP bulk string \"$-1\\r\\n\")\n```"
    },
    {
      "slug": "sq7",
      "primary_extension_slug": "sorted-sets",
      "name": "Remove a member",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for removing a member of a sorted set using the `ZREM` command.\n",
      "description_md": "In this stage, you'll add support for removing a member of a sorted set using the `ZREM` command.\n\n## The `ZREM` command\n\nThe [`ZREM`](https://redis.io/docs/latest/commands/zrem/) command is used to remove a member from a sorted set given the member's name.\n\nExample Usage:\n\n```bash\n> ZADD racer_scores 8.3 \"Sam-Bodden\"\n(integer) 1\n> ZADD racer_scores 10.5 \"Royce\"\n(integer) 1\n\n# Remove \"Royce\" from the sorted set\n> ZREM racer_scores \"Royce\"\n(integer) 1\n\n# List the remaining members\n> ZRANGE racer_scores 0 -1\n1) \"Sam-Bodden\"\n\n# Remove a non-existing member\n> ZREM racer_scores \"missing_member\"\n(integer) 0\n```\n\nIt returns the number of members removed from the sorted set. If the specified member does not exist, 0 is returned.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then create a new sorted set with multiple members.\n\n```bash\n$ redis-cli\n> ZADD zset_key 80.5 foo (Expecting \":1\\r\\n\")\n> ZADD zset_key 50.3 baz (Expecting \":1\\r\\n\")\n> ZADD zset_key 80.5 bar (Expecting \":1\\r\\n\")\n```\n\nAfter that the tester will send your program a `ZREM` command specifying the member to be removed.\n\nAs an example, the tester might send your program a command like this.\n```bash\n> ZREM zset_key \"baz\"\n# Expected: (integer) 1\n```\n\nIt will then send your program a `ZRANGE` command and check for the remaining members.\n\n```bash\n> ZRANGE zset_key 0 -1\n# Expected RESP Encoded Array: [\"bar\", \"foo\"]\n```\n\nThe tester will also send a `ZREM` command where the member doesn't exist.\n```bash\n> ZREM zset_key \"missing_member\"\n# Expected: (integer) 0\n```"
    },
    {
      "slug": "zt4",
      "primary_extension_slug": "geospatial",
      "name": "Respond to GEOADD",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for responding to the `GEOADD` command.",
      "description_md": "In this stage, you'll add support for responding to the `GEOADD` command.\n\n### Extension prerequisites\n\nThis stage depends on the [**Sorted Sets**](https://redis.io/docs/latest/data-types/sorted-sets/) extension. Before attempting this extension, please make sure you've completed the Sorted Sets extension.\n\n### The `GEOADD` command\n\nThe [`GEOADD` command](https://redis.io/docs/latest/commands/geoadd/) adds a location (with longitude, latitude, and name) to a key.\n\nExample usage:\n\n```bash\n> GEOADD places -0.0884948 51.506479 \"London\"\n(integer) 1\n```\n\nThe arguments `GEOADD` accepts are:\n\n1. `key`: The key to store the location in.\n2. `longitude`: The longitude of the location.\n3. `latitude`: The latitude of the location.\n4. `member`: The name of the location.\n\nIt returns the count of elements added, encoded as a RESP Integer.\n\nIn this stage, you'll only implement the response to the `GEOADD` command. We'll get to validating arguments and storing locations in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `GEOADD` command:\n\n```bash\n$ redis-cli GEOADD places 11.5030378 48.164271 Munich\n```\n\nThe tester will expect the response to be `:1\\r\\n`, which is 1 (number of locations added) encoded as a RESP integer.\n\n### Notes\n\n- In this stage, you only need to implement responding to the `GEOADD` command. We'll get to validating arguments and storing locations in later stages.\n"
    },
    {
      "slug": "ck3",
      "primary_extension_slug": "geospatial",
      "name": "Validate coordinates",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for validating the latitude and longitude provided in the `GEOADD` command.",
      "description_md": "In this stage, you'll add support for validating the latitude and longitude values provided in a `GEOADD` command.\n\n### Validating latitude and longitude values\n\nThe latitude and longitude values used in the `GEOADD` command should be in a certain range as per [EPSG:3857](https://epsg.io/3857).\n\n- Valid longitudes are from -180° to +180°\n  - Both these limits are inclusive, so -180° and +180° are both valid.\n- Valid latitudes are from -85.05112878° to +85.05112878°\n  - Both of these limits are inclusive, so -85.05112878° and +85.05112878° are both valid.\n  - The reason these limits are not -/+90° is because of the [Web Mercator projection](https://en.wikipedia.org/wiki/Web_Mercator_projection) that Redis uses.\n\nIf either of these values aren't within the appropriate range, `GEOADD` returns an error. Examples:\n\n```bash\n# Invalid latitude\n> GEOADD places 180 90 test1\n(error) ERR invalid longitude,latitude pair 180.000000,90.000000\n\n# Invalid longitude\n> GEOADD places 181 0.3 test2\n(error) ERR invalid longitude,latitude pair 181.000000,0.300000\n```\n\nIn this stage, you'll implement validating latitude and longitude values and returning error messages as shown above. The tester is lenient with error message formats, so you don't have to use the exact error message format mentioned above.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send multiple `GEOADD` commands.\n\nIf the coordinates are invalid, it will expect an error response. For example:\n\n```bash\n# Expecting error\n$ redis-cli GEOADD location_key 200 100 foo\n(error) ERR invalid longitude,latitude pair 200,100\n```\n\nThe returned value must:\n\n- Be a [RESP simple error](https://redis.io/docs/latest/develop/reference/protocol-spec/#simple-errors) i.e. start with `-` and end with `\\r\\n`\n- The error message must start with `ERR`, like standard Redis error messages\n- The error message must contain the word \"latitude\" if the latitude is invalid\n- The error message must contain the word \"longitude\" if the longitude is invalid\n\nFor example, if the latitude is invalid, valid error messages that the tester will accept are:\n\n```bash\n-ERR invalid latitude argument\\r\\n\n-ERR invalid latitude value\\r\\n\n-ERR latitude value (200.0) is invalid\\r\\n\n```\n\n### Notes\n\n- You don't need to implement storing locations yet, we'll get to that in later stages.\n- The boundary of latitude are clipped at -/+85.05112878° instead of -/+90°. This is because of the [Web Mercator projection](https://en.wikipedia.org/wiki/Web_Mercator_projection) that Redis uses.\n"
    },
    {
      "slug": "tn5",
      "primary_extension_slug": "geospatial",
      "name": "Store a location",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for storing a location in a sorted set.",
      "description_md": "In this stage, you'll add support for storing locations in a sorted set.\n\n### Storing locations in sorted set\n\nThe locations added using the `GEOADD` command are stored in a sorted set. Redis internally calculates a score for the specified location using a location's latitude and longitude.\n\nFor example, the following two commands are equivalent in Redis.\n\n```bash\n# Adding a location\n$ redis-cli GEOADD places_key 2.2944692 48.8584625 location\n\n# This command is equivalent to the command above\n$ redis-cli ZADD places_key 3663832614298053 location\n```\n\nIn this stage, you'll implement adding locations to a sorted set when a `GEOADD` command is run.\n\nYou can hardcode the score to be 0 for now, we'll get to calculating the score in later stages.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send a `GEOADD` command:\n\n```bash\n$ redis-cli GEOADD places 2.2944692 48.8584625 Paris\n# Expect: (integer) 1\n```\n\nThe tester will then send a `ZRANGE` command to validate that the location was added to the sorted set:\n\n```bash\n$ redis-cli ZRANGE places 0 -1\n# Expect RESP Array: [\"Paris\"]\n```\n\n### Notes\n\n- In this stage, you can hardcode the score of the location to be 0. We'll get to calculating the value of score using latitude and longitude in later stages.\n- The implementation of the `ZRANGE` command is covered in the sorted sets extension.\n"
    },
    {
      "slug": "cr3",
      "primary_extension_slug": "geospatial",
      "name": "Calculate location score",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll add support for calculating the score of a location.",
      "description_md": "In this stage, you'll add support for calculating the score of a location.\n\n### Location scores\n\nTo store locations in a sorted set, Redis converts latitude and longitude values to a single \"score\".\n\nWe've created a [GitHub repository](https://github.com/codecrafters-io/redis-geocoding-algorithm) that explains how this conversion is done. It includes:\n\n- A description of the algorithm used, along with pseudocode\n- Code samples in multiple languages.\n- A set of locations & scores to test against\n\nHere's the [repository link](https://github.com/codecrafters-io/redis-geocoding-algorithm).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then send multiple `GEOADD` commands:\n\n```bash\n$ redis-cli GEOADD places 2.2944692 48.8584625 Paris\n# Expect: (integer) 1\n$ redis-cli GEOADD places -0.127758 51.507351 London\n# Expect: (integer) 1\n```\n\nThe tester will validate that scores are calculated correctly by sending multiple `ZSCORE` commands:\n\n```bash\n$ redis-cli ZSCORE places Paris\n# Expecting bulk string: \"3663832614298053\"\n```\n\nThe calculated scores must match the expected values as described in [this repository](https://github.com/codecrafters-io/redis-geocoding-algorithm).\n"
    },
    {
      "slug": "xg4",
      "primary_extension_slug": "geospatial",
      "name": "Respond to GEOPOS",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for responding to the `GEOPOS` command.",
      "description_md": "In this stage, you'll add support for responding to the `GEOPOS` command.\n\n### The `GEOPOS` command\n\nThe `GEOPOS` command returns the longitude and latitude of the specified location.\n\nExample usage:\n\n```bash\n> GEOADD places -0.0884948 51.506479 \"London\"\n> GEOADD places 11.5030378 48.164271 \"Munich\"\n\n> GEOPOS places London\n1) 1) \"-0.08849412202835083\"\n   2) \"51.50647814139934\"\n\n> GEOPOS places Munich\n1) 1) \"11.503036916255951\"\n   2) \"48.16427086232978\"\n```\n\nIt returns an array with one entry for each location requested.\n\n- If a location exists under the key, its entry is an array of two items:\n  - Longitude (Encoded as a [RESP Bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings))\n  - Latitude (Encoded as a [RESP Bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings))\n- If either the location or key don’t exist, the corresponding entry is a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) `(*-1\\r\\n)`.\n\nTo return the latitude and longitude values, Redis decodes the \"score\" back to latitude and longitude values. We'll cover this process in later stages, for now you can hardcode the returned latitude and longitude values to be 0 (or any number).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then add multiple locations using the `GEOADD` command.\n\n```bash\n$ redis-cli\n> GEOADD location_key -0.0884948 51.506479 \"London\"\n# Expect: (integer) 1\n> GEOADD location_key 11.5030378 48.164271 \"Munich\"\n# Expect: (integer) 1\n```\n\nThe tester will then send multiple `GEOPOS` commands:\n\n```bash\n> GEOPOS location_key London Munich\n# Expecting: [[\"0\", \"0\"], [\"0\", \"0\"]], encoded as \"*2\\r\\n*2\\r\\n$1\\r\\n0\\r\\n$1\\r\\n0\\r\\n*2\\r\\n$1\\r\\n0\\r\\n$1\\r\\n0\\r\\n\"\n\n> GEOPOS location_key missing_location\n# Expecting: [nil], encoded as \"*1\\r\\n*-1\\r\\n\"\n```\n\nThe tester will assert that:\n\n- The response is a RESP array that contains as many elements as the number of locations requested\n- For each location requested:\n  - If the location exists:\n    - The corresponding element is a RESP array with two elements (i.e. longitude and latitude)\n    - Both elements are \"0\" (or any other valid floating point number), encoded as a RESP bulk string\n  - If the location doesn't exist:\n    - The corresponding element is a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) `(*-1\\r\\n)`.\n\nThe tester will also send a `GEOPOS` command using a key that doesn't exist:\n\n```bash\n> GEOPOS missing_key London Munich\n# Expecting [nil, nil], encoded as \"*2\\r\\n*-1\\r\\n*-1\\r\\n\"\n```\n\nThe tester will assert that:\n\n- The response is a RESP array that contains as many elements as the number of locations requested\n- Each element of the array is a [null array](https://redis.io/docs/latest/develop/reference/protocol-spec/#null-arrays) `(*-1\\r\\n)`\n\n### Notes\n\n- In this stage, you can hardcode the returned latitude and longitude values to be 0 (or any other valid floating point number). We'll get to testing actual latitude and longitude values in later stages.\n"
    },
    {
      "slug": "hb5",
      "primary_extension_slug": "geospatial",
      "name": "Decode coordinates",
      "difficulty": "hard",
      "marketing_md": "In this stage, you'll add support for decoding the coordinates of a location.",
      "description_md": "In this stage, you'll add support for decoding the coordinates of a location.\n\n### Decoding latitude and longitude from score\n\nThe algorithm to get back the latitude and longitude is essentially the reverse of the one used to compute the score from them.\n\nThe [GitHub repository](https://github.com/codecrafters-io/redis-geocoding-algorithm) we referenced earlier explains how this conversion is done. It includes:\n\n- A description of the algorithm used, along with pseudocode\n- Code samples in multiple languages.\n- A set of locations & scores to test against\n\nHere's the [repository link](https://github.com/codecrafters-io/redis-geocoding-algorithm).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will add multiple locations using the `ZADD` command. The scores used are valid scores that can be converted back to latitude and longitude values.\n\n```bash\n$ redis-cli\n> ZADD location_key 3663832614298053 \"Foo\"\n> ZADD location_key 3876464048901851 \"Bar\"\n> ZADD location_key 3468915414364476 \"Baz\"\n> ZADD location_key 3781709020344510 \"Caz\"\n```\n\nThe tester will then send multiple `GEOPOS` commands:\n\n```bash\n> GEOPOS location_key Foo\n# Expecting [[\"2.294471561908722\", \"48.85846255040141\"]]\n```\n\nThe tester will validate that the response is a RESP array, which is encoded as:\n\n```\n*1\\r\\n\n*2\\r\\n\n$17\\r\\n\n2.294471561908722\\r\\n\n$17\\r\\n\n48.85846255040141\\r\\n\n```\n\n### Notes\n\n- The conversion from latitude/longitude to score and back is lossy, so the tester will be lenient in checking the coordinates provided - it will accept any coordinates that are within 6 decimal places of the original values. For example, for the example shown above, any of the following values will be accepted:\n  - `[\"2.2944715\", \"48.8584625\"]`\n  - `[\"2.294472\", \"48.858463\"]`\n  - `[\"2.294471594\", \"48.858462987\"]`\n"
    },
    {
      "slug": "ek6",
      "primary_extension_slug": "geospatial",
      "name": "Calculate distance",
      "difficulty": "medium",
      "marketing_md": "In this stage, you'll add support for calculating the distance between two locations using the `GEODIST` comamnd.",
      "description_md": "In this stage, you'll add support for calculating the distance between two locations using the `GEODIST` command.\n\n### The `GEODIST` command\n\nThe `GEODIST` command returns the distance between two members of a key.\n\nExample usage:\n\n```bash\n> GEODIST places Munich Paris\n\"682477.7582\"\n```\n\nThe distance is returned in meters, encoded as a [RESP bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\nRedis uses the [Haversine's Formula](https://rosettacode.org/wiki/Haversine_formula) to calculate the distance between two points. You can see how this is done in the Redis source code [here](https://github.com/redis/redis/blob/4322cebc1764d433b3fce3b3a108252648bf59e7/src/geohash_helper.c#L228C1-L228C72).\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will then add multiple locations using the `GEOADD` command:\n\n```bash\n$ redis-cli\n> GEOADD places 11.5030378 48.164271 \"Munich\"\n> GEOADD places 2.2944692 48.8584625 \"Paris\"\n```\n\nThe tester will then send multiple `GEODIST` commands specifying two locations:\n\n```bash\n> GEODIST places Munich Paris\n# Expecting \"682477.7582\"\n```\n\nThe tester will validate that the response is a RESP bulk string that contains the distance between the two locations, for example:\n\n```bash\n$11\\r\\n682477.7582\\r\\n\n```\n\n### Notes\n\n- When computing distance, set the value of Earth's radius to 6372797.560856 meters. This is the exact value [used by Redis](https://github.com/redis/redis/blob/35aacdf80a0871c933047fc46655b98a73a9374e/src/geohash_helper.c#L52).\n\n- The distance should match the actual distance between the provided locations with a precision of up to 4 decimal places after rounding. For example, if the expected distance is 12345.6789, any of the following returned values will be accepted:\n  - `12345.67891`\n  - `12345.6789`\n  - `12345.67889`\n"
    },
    {
      "slug": "rm9",
      "primary_extension_slug": "geospatial",
      "name": "Search within radius",
      "difficulty": "easy",
      "marketing_md": "In this stage, you'll add support for searching locations near a coordinate within a given radius using the `GEOSEARCH` command.",
      "description_md": "In this stage, you'll add support for searching locations within a given radius using the `GEOSEARCH` command.\n\n### The GEOSEARCH command\n\nThe `GEOSEARCH` command lets you search for locations within a given radius.\n\nIt supports several search modes. In our implementation, we'll focus only on the `FROMLONLAT` mode. The `FROMLONLAT` mode searches by directly specifying longitude and latitude.\n\nExample usage:\n\n```bash\n> GEOSEARCH places FROMLONLAT 2 48 BYRADIUS 100 m\n1) \"Paris\"\n```\n\nThe example command above searches for locations in the `places` key that are within 100 meters of the point (longitude: 2, latitude: 48).\n\nThe response is a RESP array containing the names of the locations that match the search criteria, each encoded as a [RESP bulk string](https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings).\n\nNote that there are two options we passed to the command:\n\n- `FROMLONLAT <longitude> <latitude>` — This option specifies the center point for the search.\n- `BYRADIUS <radius> <unit>` — This option searches within a circular area of the given radius and unit (m, km, mi, etc.).\n\nRedis supports other such options, but in this challenge we'll only use `FROMLONLAT` and `BYRADIUS`.\n\n### Tests\n\nThe tester will execute your program like this:\n\n```bash\n$ ./your_program.sh\n```\n\nIt will add multiple locations using the `GEOADD` command.\n\n```bash\n$ redis-cli\n> GEOADD places 11.5030378 48.164271 \"Munich\"\n> GEOADD places 2.2944692 48.8584625 \"Paris\"\n> GEOADD places -0.0884948 51.506479 \"London\"\n```\n\nThe tester will then send multiple `GEOSEARCH` commands:\n\n```bash\n> GEOSEARCH places FROMLONLAT 2 48 BYRADIUS 100000 m\n# Expecting [\"Paris\"]\n\n> GEOSEARCH places FROMLONLAT 2 48 BYRADIUS 500000 m\n# Expecting [\"Paris, \"London\"] (Any order)\n\n> GEOSEARCH places FROMLONLAT 11 50 BYRADIUS 300000 m\n# Expecting [\"Munich\"]\n```\n\nThe tester will validate that the response is a RESP array, for example\n\n```\n*2\\r\\n\n$5\\r\\n\nParis\\r\\n\n$6\\r\\n\nLondon\\r\\n\n```\n\nLocations can be returned in any order.\n\n### Notes\n\n- The tester will always use the `FROMLONLAT` and `BYRADIUS` options when sending a `GEOSEARCH` command.\n"
    }
  ]
}
