export default {
  "slug": "git",
  "name": "Build your own Git",
  "short_name": "Git",
  "release_status": "live",
  "description_md": "Git is a version control system used to track changes in source code. In this challenge, you'll build your own Git implementation that\nis capable of cloning a public repository from GitHub.\n\nAlong the way, you'll learn about the .git directory, Git objects, plumbing commands and more.",
  "short_description_md": "Learn about git objects, plumbing commands and more",
  "completion_percentage": 10,
  "languages": [
    {
      "slug": "c"
    },
    {
      "slug": "cpp"
    },
    {
      "slug": "csharp",
      "release_status": "beta"
    },
    {
      "slug": "go"
    },
    {
      "slug": "haskell"
    },
    {
      "slug": "java",
      "release_status": "beta"
    },
    {
      "slug": "javascript"
    },
    {
      "slug": "python"
    },
    {
      "slug": "ruby"
    },
    {
      "slug": "rust"
    },
    {
      "slug": "kotlin"
    },
    {
      "slug": "typescript",
      "release_status": "beta"
    },
    {
      "slug": "zig",
      "release_status": "beta"
    }
  ],
  "marketing": {
    "difficulty": "hard",
    "sample_extension_idea_title": "Push to remote repository",
    "sample_extension_idea_description": "A Git implementation that can push changes to a remote repository",
    "testimonials": [
      {
        "author_name": "Beyang Liu",
        "author_description": "CTO, Sourcegraph",
        "author_avatar": "https://codecrafters.io/images/external/testimonials/beyang-liu.jpeg",
        "link": "https://twitter.com/beyang/status/1271225214886506496",
        "text": "Found out about CodeCrafters from a colleague. It's a tutorial site that has you build your own version of things\nlike Git and Docker from scratch. A cool way to build a stronger mental model of how those tools work."
      },
      {
        "author_name": "Lacronicus",
        "author_description": "Reddit user",
        "author_avatar": "https://codecrafters.io/images/external/testimonials/reddit-user.png",
        "link": "https://www.reddit.com/r/programming/comments/fefrka/advanced_programming_challenges/fjoxu7n/",
        "text": "Never in my life have I needed something so much and not known until I received it."
      }
    ]
  },
  "stages": [
    {
      "slug": "gg4",
      "name": "Initialize the .git directory",
      "difficulty": "very_easy",
      "description_md": "In this stage, you'll implement the `git init` command.\n\n### The `git init` command\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  `git init` initializes a Git repository by creating a `.git` directory with some files\n  & directories inside it.\n\n  You can learn more about what's inside the `.git` folder [here](https://blog.meain.io/2023/what-is-in-dot-git/). We've\n  included a description of the files & directores we'll be dealing with in this stage below.\n\n</details>\n\n### The `.git` directory\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  At a bare minimum, a `.git` directory should contain the following files & directories:\n\n  ```\n  - .git/\n    - objects/\n    - refs/\n    - HEAD (should contain \"ref: refs/heads/main\\n\" for a new repository)\n  ```\n\n  - `objects/`\n    - This directory contains [Git objects](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects).\n    - We'll learn more about what Git objects are in later stages.\n  - `refs/`\n    - This directory contains [Git references](https://git-scm.com/book/en/v2/Git-Internals-Git-References).\n    - We'll deal with this in later stages too.\n  - `HEAD`\n    - This file contains a reference to the currently checked out branch.\n    - For a new repository, it's contents will be `ref: refs/heads/main\\n`.\n\n  You can learn more about these in detail [here](https://blog.meain.io/2023/what-is-in-dot-git/).\n</details>\n\n### Tests\n\nThe tester will run your program in a new empty directory like this:\n\n```bash\n# Create a new directory and cd into it\n$ mkdir test_dir && cd test_dir\n\n# Run your program\n$ /path/to/your_program.sh init\n```\n\nIt'll then check if the `.git` directory and its contents are created correctly.\n\n```bash\n# Check if .git directory exists\n$ test -d .git\n\n# Check if .git/objects directory exists\n$ test -d .git/objects\n\n# Check if .git/refs directory exists\n$ test -d .git/refs\n\n# Check if .git/HEAD file exists\n$ test -f .git/HEAD\n\n# Check if .git/HEAD contains either \"ref: refs/heads/main\\n\" or \"ref: refs/heads/master\\n\"\n$ cat .git/HEAD\n```\n\n### Notes\n\n- Git actually creates more files & directories than the ones mentioned above when you run `git init`. We've only included the ones\n  that are absolutely necessary for Git to function properly.\n- The `.git/HEAD` file has a newline at the end.\n- The `.git/HEAD` file can contain either `ref: refs/heads/main\\n` or `ref: refs/heads/master\\n`, the tester will\n  work with either of these.",
      "marketing_md": "In this stage, you'll implement the `git init` command. You'll initialize\na git repository by creating a `.git` directory and some files inside it.",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/03984478122959f23a866a0df102413a5ac08e67/internal/stage_init.go#L12"
    },
    {
      "slug": "ic4",
      "name": "Read a blob object",
      "difficulty": "medium",
      "description_md": "In this stage, you'll add support for reading a blob using the `git cat-file` command.\n\n### Git objects\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  In this challenge, we'll deal with three [Git\n  objects](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects):\n\n  - Blobs (**This stage**)\n    - These are used to store file data.\n    - Blobs only store the contents of a file, not its name or permissions.\n  - Trees (Future stages)\n    - These are used to store directory structures.\n    - The information stored can include things like what files/directories are in a tree, their names and permissions.\n  - Commits (Future stages)\n    - These are used to store commit data.\n    - The information stored can include things like the commit message, author, committer, parent commit(s) and more.\n\n\n  All Git objects are identifiable by a 40-character SHA-1 hash, also known as the \"object hash\".\n\n  Here's an example of an object hash: `e88f7a929cd70b0274c4ea33b209c97fa845fdbc`.\n</details>\n\n### Git Object Storage\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  Git objects are stored in the `.git/objects` directory. The path to an object is derived from its hash.\n\n  The path for the object with the hash `e88f7a929cd70b0274c4ea33b209c97fa845fdbc` would be:\n\n  ```bash\n  .git/objects/e8/8f7a929cd70b0274c4ea33b209c97fa845fdbc\n  ```\n\n  You'll see that the file isn't placed directly in the `.git/objects` directory. Instead, it's placed in a directory named with the\n  first two characters of the object's hash. The remaining 38 characters are used as the file name.\n\n  Each Git object has its own format for storage. We'll look at how Blobs are stored in this stage, and we'll cover\n  other objects in future stages.\n</details>\n\n### Blob Object Storage\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  Each Git Blob is stored as a separate file in the `.git/objects` directory. The file contains a header and the contents of\n  the blob object, compressed using Zlib.\n\n  The format of a blob object file looks like this (after Zlib decompression):\n\n  ```\n  blob <size>\\0<content>\n  ```\n\n  - `<size>` is the size of the content (in bytes)\n  - `\\0` is a null byte\n  - `<content>` is the actual content of the file\n\n  For example, if the contents of a file are `hello world`, the blob object file would look like this (after Zlib decompression):\n\n  ```\n  blob 11\\0hello world\n  ```\n</details>\n\n### The cat-file command\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  In this stage, you'll read a blob from a git repository by reading its contents from the `.git/objects` directory.\n\n  You'll do this using the first of multiple [\"plumbing\" commands](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)\n  we'll encounter in this challenge: [`git cat-file`](https://git-scm.com/docs/git-cat-file).\n\n  `git cat-file` is used to view the type of an object, its size, and its content. Example usage:\n\n  ```bash\n  $ git cat-file -p <blob_sha>\n  hello world # This is the contents of the blob\n  ```\n\n  To implement this, you'll need to:\n\n  - Read the contents of the blob object file from the `.git/objects` directory\n  - Decompress the contents using Zlib\n  - Extract the actual \"content\" from the decompressed data\n  - Print the content to stdout\n\n</details>\n\n### Tests\n\nThe tester will first initialize a new git repository using your program, and then insert a blob with random contents into the `.git/objects` directory:\n\n```bash\n$ mkdir /tmp/test_dir && cd /tmp/test_dir\n$ /path/to/your_program.sh init\n$ echo \"hello world\" > test.txt # The tester will use a random string, not \"hello world\"\n$ git hash-object -w test.txt\n3b18e512dba79e4c8300dd08aeb37f8e728b8dad\n```\n\nAfter that, it'll run your program like this:\n\n```bash\n$ /path/to/your_program.sh cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad\nhello world\n```\n\nThe tester will verify that the output of your program matches the contents of the blob.\n\n### Notes\n\n- In many programming languages the default print function (like [`fmt.Println`](https://pkg.go.dev/fmt#example-Println))\n  will append a newline to the output. The output of `cat-file` must not contain a\n  newline at the end, so you might need to use a different function to print the output.\n\n{{#lang_is_python}}\n- Keep in mind that Git uses [Zlib](https://en.wikipedia.org/wiki/Zlib) to\n  compress objects. You can use Python's built-in\n  [zlib](https://docs.python.org/3/library/zlib.html) library to read these\n  compressed files.\n{{/lang_is_python}}\n\n{{#lang_is_ruby}}\n- Keep in mind that Git uses [Zlib](https://en.wikipedia.org/wiki/Zlib) to\n  compress objects. You can use Ruby's built-in\n  [Zlib](https://ruby-doc.org/stdlib-2.7.0/libdoc/zlib/rdoc/Zlib.html)\n  library to read these compressed files.\n{{/lang_is_ruby}}\n\n{{#lang_is_go}}\n- Keep in mind that Git uses [Zlib](https://en.wikipedia.org/wiki/Zlib) to\n  compress objects. You can use Go's built-in\n  [compress/zlib](https://golang.org/pkg/compress/zlib/) package to read\n these compressed files.\n{{/lang_is_go}}\n\n{{#lang_is_rust}}\n- Keep in mind that Git uses [Zlib](https://en.wikipedia.org/wiki/Zlib) to\n  compress objects. You can use the\n  [flate2](https://crates.io/crates/flate2) crate to read these compressed\n  files, we've included it in the `Cargo.toml` file.\n{{/lang_is_rust}}\n\n{{^lang_is_python}}\n{{^lang_is_ruby}}\n{{^lang_is_go}}\n{{^lang_is_rust}}\n- Keep in mind that Git uses [Zlib](https://en.wikipedia.org/wiki/Zlib) to\n  compress objects. Many languages have utils for dealing with zlib data in their standard library. If not,\n  you might need to use a third-party library to read these compressed files.\n{{/lang_is_rust}}\n{{/lang_is_go}}\n{{/lang_is_ruby}}\n{{/lang_is_python}}",
      "marketing_md": "In this stage, you'll read a blob from your git repository by fetching its\ncontents from the `.git/objects` directory.\n\nYou'll do this using the first of multiple [\"plumbing\"\ncommands](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain)\nwe'll encounter in this challenge: [`git\ncat-file`](https://git-scm.com/docs/git-cat-file).",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/03984478122959f23a866a0df102413a5ac08e67/internal/stage_read_blob.go#L18"
    },
    {
      "slug": "jt4",
      "name": "Create a blob object",
      "difficulty": "medium",
      "description_md": "In this stage, you'll implement support for creating a blob using the [`git\nhash-object`](https://git-scm.com/docs/git-hash-object) command.\n\n### The `git hash-object` command\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  `git hash-object` is used to compute the SHA-1 hash of a Git object. When used with the `-w` flag, it\n  also writes the object to the `.git/objects` directory.\n\n  Here's an example of using `git hash-object`:\n\n  ```bash\n  # Create a file with some content\n  $ echo -n \"hello world\" > test.txt\n\n  # Compute the SHA-1 hash of the file + write it to .git/objects\n  $ git hash-object -w test.txt\n  95d09f2b10159347eece71399a7e2e907ea3df4f\n\n  # Verify that the file was written to .git/objects\n  $ file .git/objects/95/d09f2b10159347eece71399a7e2e907ea3df4f\n  .git/objects/95/d09f2b10159347eece71399a7e2e907ea3df4f: zlib compressed data\n  ```\n\n</details>\n\n### Blob Object Storage (Recap)\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  As mentioned in the previous stage, each Git Blob is stored as a separate file in the `.git/objects` directory. The file\n  contains a header and the contents of the blob object, compressed using Zlib.\n\n  The format of a blob object file looks like this (after Zlib decompression):\n\n  ```\n  blob <size>\\0<content>\n  ```\n\n  - `<size>` is the size of the content (in bytes)\n  - `\\0` is a null byte\n  - `<content>` is the actual content of the file\n\n  For example, if the contents of a file are `hello world`, the blob object file would look like this (after Zlib decompression):\n\n  ```\n  blob 11\\0hello world\n  ```\n\n</details>\n\n### Tests\n\nThe tester will first initialize a new git repository using your program:\n\n```bash\n$ mkdir test_dir && cd test_dir\n$ /path/to/your_program.sh init\n```\n\nIt'll write some random data to a file:\n\n```bash\n$ echo \"hello world\" > test.txt\n```\n\nIt'll then run your program like this:\n\n```bash\n$ ./your_program.sh hash-object -w test.txt\n3b18e512dba79e4c8300dd08aeb37f8e728b8dad\n```\n\nThe tester will verify that:\n\n- Your program prints a 40-character SHA-1 hash to stdout\n- The file written to `.git/objects` matches what the official `git` implementation would write\n\n### Notes\n\n- Although the object file is stored with zlib compression, the SHA-1 hash needs to be computed over\n  the \"uncompressed\" contents of the file, not the compressed version.\n- The input for the SHA-1 hash is the header (`blob <size>\\0`) + the actual contents of the file,\n  not just the contents of the file.\n{{#lang_is_c}}\n- You can use `#include <openssl/sha.h>` to access OpenSSL’s [SHA1()](https://www.openssl.org/docs/man3.0/man3/SHA1.html) hashing function.\n{{/lang_is_c}}\n{{#lang_is_cpp}}\n- You can use `#include <openssl/sha.h>` to access OpenSSL’s [SHA1()](https://www.openssl.org/docs/man3.0/man3/SHA1.html) hashing function.\n{{/lang_is_cpp}}",
      "marketing_md": "In the previous stage, we learnt how to read a blob. In this stage, we'll\npersist a blob by implementing the `git hash-object` command.",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/master/internal/stage_create_blob.go"
    },
    {
      "slug": "kp1",
      "name": "Read a tree object",
      "difficulty": "medium",
      "description_md": "In this stage, you'll implement the `git ls-tree` command, which is used to inspect a tree object.\n\n### Tree objects\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  In this stage, we'll deal with our next Git object type: [trees](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects#_tree_objects).\n\n  Trees are used to store directory structures.\n\n  A tree object has multiple \"entries\". Each entry includes:\n\n  - A SHA-1 hash that points to a blob or tree object\n    - If the entry is a file, this points to a blob object\n    - If the entry is a directory, this points to a tree object\n  - The name of the file/directory\n  - The mode of the file/directory\n    - This is a simplified version of the permissions you'd see in a Unix file system.\n    - For files, the valid values are:\n        - `100644` (regular file)\n        - `100755` (executable file)\n        - `120000` (symbolic link)\n    - For directories, the value is `40000`\n    - There are other values for submodules, but we won't be dealing with those in this challenge.\n\n  For example, if you had a directory structure like this:\n\n  ```\n  your_repo/\n    - file1\n    - dir1/\n      - file_in_dir_1\n      - file_in_dir_2\n    - dir2/\n      - file_in_dir_3\n  ```\n\n  The entries in the tree object would look like this:\n\n  ```\n  40000 dir1 <tree_sha_1>\n  40000 dir2 <tree_sha_2>\n  100644 file1 <blob_sha_1>\n  ```\n\n  - Line 1 (`40000 dir1 <tree_sha_1>`) indicates that `dir1` is a directory with the SHA hash `<tree_sha_1>`\n  - Line 2 (`40000 dir2 <tree_sha_2>`) indicates that `dir2` is a directory with the SHA hash `<tree_sha_2>`\n  - Line 3 (`100644 file1 <blob_sha_1>`) indicates that `file1` is a regular file with the SHA hash `<blob_sha_1>`\n\n  `dir1` and `dir2` would be tree objects themselves, and their entries would contain the files/directories inside them.\n\n</details>\n\n### The `ls-tree` command\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  The `git ls-tree` command is used to inspect a tree object.\n\n  For a directory structure like this:\n\n  ```\n  your_repo/\n    - file1\n    - dir1/\n      - file_in_dir_1\n      - file_in_dir_2\n    - dir2/\n      - file_in_dir_3\n  ```\n\n  The output of `git ls-tree` would look like this:\n\n  ```bash\n  $ git ls-tree <tree_sha>\n  040000 tree <tree_sha_1>\tdir1\n  040000 tree <tree_sha_2>\tdir2\n  100644 blob <blob_sha_1>\tfile1\n  ```\n\n  Note that the output is alphabetically sorted, this is how Git stores entries in the tree object internally.\n\n  In this stage you'll implement the `git ls-tree` command with the `--name-only` flag. Here's how the output looks with\n  the `--name-only` flag:\n\n  ```bash\n  $ git ls-tree --name-only <tree_sha>\n  dir1\n  dir2\n  file1\n  ```\n\n  The tester uses `--name-only` since this output format is easier to test against.\n\n  We recommend implementing the full `ls-tree` output too since that'll require that you parse all data\n  in the tree object, not just filenames.\n\n</details>\n\n### Tree Object Storage\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  Just like blobs, tree objects are stored in the `.git/objects` directory. If the hash of a tree object is `e88f7a929cd70b0274c4ea33b209c97fa845fdbc`,\n  the path to the object would be `.git/objects/e8/8f7a929cd70b0274c4ea33b209c97fa845fdbc`.\n\n  The format of a tree object file looks like this (after Zlib decompression):\n\n  ```\n  tree <size>\\0\n  <mode> <name>\\0<20_byte_sha>\n  <mode> <name>\\0<20_byte_sha>\n  ```\n\n  (The above code block is formatted with newlines for readability, but the actual file doesn't contain newlines)\n\n  - The file starts with `tree <size>\\0`. This is the \"object header\", similar to what we saw with blob objects.\n  - After the header, there are multiple entries. Each entry is of the form `<mode> <name>\\0<sha>`.\n    - `<mode>` is the mode of the file/directory (check the previous section for valid values)\n    - `<name>` is the name of the file/directory\n    - `\\0` is a null byte\n    - `<20_byte_sha>` is the 20-byte SHA-1 hash of the blob/tree (this is **not** in hexadecimal format)\n\n  You can read more about the internal format of a tree object [here](https://stackoverflow.com/questions/14790681/what-is-the-internal-format-of-a-git-tree-object).\n\n</details>\n\n### Tests\n\nThe tester will use your program to initialize a new repository:\n\n```bash\n$ mkdir test_dir && cd test_dir\n$ /path/to/your_program.sh init\n```\n\nIt'll then write a tree object to the `.git/objects` directory.\n\nIt'll then run your program like this:\n\n```bash\n$ /path/to/your_program.sh ls-tree --name-only <tree_sha>\n```\n\nIt'll verify that the output of your program matches the contents of the tree object.\n\nFor a directory structure like this:\n\n```\nyour_repo/\n  - file1\n  - dir1/\n    - file_in_dir_1\n    - file_in_dir_2\n  - dir2/\n    - file_in_dir_3\n```\n\nThe output expected is:\n\n```\ndir1\ndir2\nfile1\n```\n\n### Notes\n\n- In a tree object file, the SHA-1 hashes are not in hexadecimal format. They're just raw bytes (20 bytes long).\n- In a tree object file, entries are sorted by their name. The output of `ls-tree` matches this order.",
      "marketing_md": "Now that we've learnt how to read/write blobs, let's move onto our next\nGit object: [the tree](https://developer.github.com/v3/git/trees/). In\nthis stage, you'll read a tree object from storage by implementing the\n`git ls-tree` command.",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/03984478122959f23a866a0df102413a5ac08e67/internal/stage_read_tree.go#L20"
    },
    {
      "slug": "fe4",
      "name": "Write a tree object",
      "difficulty": "medium",
      "description_md": "In this stage, you'll implement writing a tree to the `.git/objects` directory.\n\n### The `git write-tree` command\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  The `git write-tree` command creates a tree object from the current state of the \"staging area\". The\n  staging area is a place where changes go when you run `git add`.\n\n  In this challenge we won't implement a staging area, we'll just assume that all files in the working directory are staged.\n\n  Here's an example of using `git write-tree`:\n\n  ```bash\n  # Create a file with some content\n  $ echo \"hello world\" > test.txt\n\n  # Add the file to the staging area (we won't implement a staging area in this challenge)\n  $ git add test.txt\n\n  # Write the tree to .git/objects\n  $ git write-tree\n  4b825dc642cb6eb9a060e54bf8d69288fbee4904\n  ```\n\n  The output of `git write-tree` is the 40-char SHA-1 hash of the tree object that was written to `.git/objects`.\n\n  To implement this, you'll need to:\n\n  - Iterate over the files/directories in the working directory\n  - If the entry is a file, create a blob object and record its SHA-1 hash\n  - If the entry is a directory, recursively create a tree object and record its SHA-1 hash\n  - Once you have all the entries and their SHA-1 hashes, write the tree object to the `.git/objects` directory\n\n  If you're testing this against `git` locally, make sure to run `git add .` before `git write-tree`, so that\n  all files in the working directory are staged.\n\n</details>\n\n### Tree File Storage (recap)\n\n<details>\n  <summary>Click to expand/collapse</summary>\n\n  We covered the format of a tree object file in the previous stage. Here's a quick recap of what\n  a tree object file looks like (before Zlib compression):\n\n  ```\n  tree <size>\\0\n  <mode> <name>\\0<20_byte_sha>\n  <mode> <name>\\0<20_byte_sha>\n  ```\n\n  (The above code block is formatted with newlines for readability, but the actual file doesn't contain newlines)\n\n  - The file starts with `tree <size>\\0`. This is the \"object header\", similar to what we saw with blob objects.\n  - After the header, there are multiple entries. Each entry is of the form `<mode> <name>\\0<sha>`.\n    - `<mode>` is the mode of the file/directory\n    - `<name>` is the name of the file/directory\n    - `\\0` is a null byte\n    - `<20_byte_sha>` is the 20-byte SHA-1 hash of the blob/tree (this is **not** in hexadecimal format)\n\n  You can read more about the internal format of a tree object [here](https://stackoverflow.com/questions/14790681/what-is-the-internal-format-of-a-git-tree-object).\n\n</details>\n\n### Tests\n\nThe tester will initialize a new Git repository using your program:\n\n```bash\n$ mkdir test_dir && cd test_dir\n$ /path/to/your_program.sh init\n```\n\nIt'll create some random files and directories:\n\n```bash\n$ echo \"hello world\" > test_file_1.txt\n$ mkdir test_dir_1\n$ echo \"hello world\" > test_dir_1/test_file_2.txt\n$ mkdir test_dir_2\n$ echo \"hello world\" > test_dir_2/test_file_3.txt\n```\n\nAnd then run your program like this:\n\n```bash\n$ /path/to/your_program.sh write-tree\n4b825dc642cb6eb9a060e54bf8d69288fbee4904\n```\n\nYou're expected to write the entire working directory as a tree object\nand print the 40-char SHA-1 hash to stdout.\n\nThe tester will verify that the output of your program matches the SHA-1 hash\nof the tree object that the official `git` implementation would write.\n\n### Notes\n\n- Remember to ignore the `.git` directory when creating entries in the tree object.\n- Your implementation of `git write-tree` will need to handle nested directories. A recursive implementation\n  will help here, since you'll need to create tree objects for each subdirectory to be able to create the\n  parent directory's tree object.\n- The implementation of `git write-tree` here differs slightly from the official `git` implementation. The\n  official `git` implementation uses the staging area to determine what to write to the tree object. We'll\n  just assume that all files in the working directory are staged.",
      "marketing_md": "In this stage, you'll write a tree to git storage by implementing the [`git\nwrite-tree`](https://git-scm.com/docs/git-write-tree) command.\n\nTo keep things simple, we won't implement an `index`, we'll just assume\nthat all changes in the worktree are staged.",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/03984478122959f23a866a0df102413a5ac08e67/internal/stage_write_tree.go#L21"
    },
    {
      "slug": "jm9",
      "name": "Create a commit",
      "difficulty": "medium",
      "description_md": "In this stage, you'll implement the `git commit-tree` command, which is used to create a commit object.\n\n### Commits\n\nLet's move on to the last git object we'll be dealing with in this\nchallenge: [the commit](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects#_git_commit_objects).\n\nA commit object contains information like:\n\n- Committer/Author name + email\n- Timestamp\n- Tree SHA\n- Parent commit SHA(s), if any\n\nWe don't have a detailed description of the commit object format here, but you can read more about it\n[here](https://stackoverflow.com/questions/22968856/what-is-the-file-format-of-a-git-commit-object-data-structure).\n\n### The `git commit-tree` command\n\nThe `git commit-tree` command creates a commit object. Example usage:\n\n```bash\n# Create a new directory and cd into it\n$ mkdir test_dir && cd test_dir\n\n# Initialize a new git repository\n$ git init\nInitialized empty Git repository in /path/to/test_dir/.git/\n\n# Create a tree, get its SHA\n$ echo \"hello world\" > test.txt\n$ git add test.txt\n$ git write-tree\n4b825dc642cb6eb9a060e54bf8d69288fbee4904\n\n# Create the initial commit\n$ git commit-tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904 -m \"Initial commit\"\n3b18e512dba79e4c8300dd08aeb37f8e728b8dad\n\n# Write some changes, get another tree SHA\n$ echo \"hello world 2\" > test.txt\n$ git add test.txt\n$ git write-tree\n5b825dc642cb6eb9a060e54bf8d69288fbee4904\n\n# Create a new commit with the new tree SHA\n$ git commit-tree 5b825dc642cb6eb9a060e54bf8d69288fbee4904 -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad -m \"Second commit\"\n```\n\nThe output of `git commit-tree` is the 40-char SHA-1 hash of the commit object that was written to `.git/objects`.\n\n### Tests\n\nYour program will be invoked like this:\n\n```\n$ ./your_program.sh commit-tree <tree_sha> -p <commit_sha> -m <message>\n```\n\nYour program must create a commit object and print its 40-char SHA-1 hash to\nstdout.\n\nTo keep things simple:\n\n- You'll receive exactly one parent commit\n- You'll receive exactly one line in the message\n- You're free to hardcode any valid name/email for the author/committer fields\n\n\nTo verify your changes, the tester will read the commit object from the\n`.git` directory. It'll use the `git show` command to do this.",
      "marketing_md": "Let's move on to the last git object we'll be dealing with in this\nchallenge: the commit. In this stage, you'll create a commit by\nimplementing the [`git commit-tree`](https://git-scm.com/docs/git-commit-tree)\ncommand.",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/master/internal/stage_create_commit.go"
    },
    {
      "slug": "mg6",
      "name": "Clone a repository",
      "difficulty": "hard",
      "description_md": "In this stage, you'll implement cloning a public repository from GitHub.\n\nThis is the last stage of the challenge, and probably the hardest across all of CodeCrafters!\n\nWe might split this into an extension with multiple stages in the future, but for now it's just one big stage.\n\nWe don't have detailed instructions for this stage, so you're all on your own here. A few pointers to get you started:\n\n- [This forum post](https://forum.codecrafters.io/t/step-for-git-clone-implementing-the-git-protocol/4407) has some\n  suggestions on how to incrementally implement this.\n- You'll need to use Git's [Smart HTTP transfer protocol](https://www.git-scm.com/docs/http-protocol) for this.\n- To know more about the protocol format, we recommend reading:\n  - [gitprotocol-pack](https://git-scm.com/docs/gitprotocol-pack)\n  - [gitformat-pack](https://git-scm.com/docs/gitformat-pack)\n  - [Unpacking Git packfiles](https://codewords.recurse.com/issues/three/unpacking-git-packfiles)\n  - [Sneaky git number encoding](https://medium.com/@concertdaw/sneaky-git-number-encoding-ddcc5db5329f)\n\n{{#lang_is_rust}}\nYou can use the [reqwest](https://crates.io/crates/reqwest) crate to make\nHTTP requests, we've included it in the `Cargo.toml` file.\n{{/lang_is_rust}}\n\n### Tests\n\nThe tester will run your program like this:\n\n```bash\n$ /path/to/your_program.sh clone https://github.com/blah/blah <some_dir>\n```\n\nYour program must create `<some_dir>` and clone the given repository into it.\n\nTo verify your changes, the tester will:\n\n- Check the contents of a random file\n- Read commit object attributes from the `.git` directory",
      "marketing_md": "This is the last stage of the challenge, and probably the hardest! In this\nstage, you'll clone a public repository from GitHub. To do this, you'll\nuse one of Git's [Transfer\nprotocols](https://git-scm.com/book/en/v2/Git-Internals-Transfer-Protocols).",
      "tester_source_code_url": "https://github.com/codecrafters-io/git-tester/blob/03984478122959f23a866a0df102413a5ac08e67/internal/stage_clone_repository.go#L80"
    }
  ]
}
